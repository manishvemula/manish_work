     1                                  ;------------------------------------------------------------------------------
     2                                  ; @file
     3                                  ; This file includes all other code files to assemble the reset vector code
     4                                  ;
     5                                  ; Copyright (c) 2008 - 2013, Intel Corporation. All rights reserved.<BR>
     6                                  ; Copyright (c) 2020 - 2024, Advanced Micro Devices, Inc. All rights reserved.<BR>
     7                                  ; SPDX-License-Identifier: BSD-2-Clause-Patent
     8                                  ;
     9                                  ;------------------------------------------------------------------------------
    10                                  
    11                                  ;
    12                                  ; If neither ARCH_IA32 nor ARCH_X64 are defined, then try to include
    13                                  ; Base.h to use the C pre-processor to determine the architecture.
    14                                  ;
    15                                  %ifndef ARCH_IA32
    16                                    %ifndef ARCH_X64
    17                                  
    18                                  
    19                                  
    20                                  
    21                                        %define ARCH_X64
    22                                  
    23                                    %endif
    24                                  %endif
    25                                  
    26                                  %ifdef ARCH_IA32
    27                                    %ifdef ARCH_X64
    28                                      %error "Only one of ARCH_IA32 or ARCH_X64 can be defined."
    29                                    %endif
    30                                  %elifdef ARCH_X64
    31                                  %else
    32                                    %error "Either ARCH_IA32 or ARCH_X64 must be defined."
    33                                  %endif
    34                                  
    35                                  %include "CommonMacros.inc"
    36                              <1> ;------------------------------------------------------------------------------
    37                              <1> ; @file
    38                              <1> ; Common macros used in the ResetVector VTF module.
    39                              <1> ;
    40                              <1> ; Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
    41                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
    42                              <1> ;
    43                              <1> ;------------------------------------------------------------------------------
    44                              <1> 
    45                              <1> %define ADDR16_OF(x) (0x10000 - fourGigabytes + x)
    46                              <1> %define ADDR_OF(x) (0x100000000 - fourGigabytes + x)
    47                              <1> 
    48                              <1> %macro  OneTimeCall 1
    49                              <1>     jmp     %1
    50                              <1> %1 %+ OneTimerCallReturn:
    51                              <1> %endmacro
    52                              <1> 
    53                              <1> %macro  OneTimeCallRet 1
    54                              <1>     jmp     %1 %+ OneTimerCallReturn
    55                              <1> %endmacro
    56                              <1> 
    57                              <1> StartOfResetVectorCode:
    58                              <1> 
    59                              <1> %define ADDR_OF_START_OF_RESET_CODE ADDR_OF(StartOfResetVectorCode)
    60                              <1> 
    36                                  
    37                                  %include "PostCodes.inc"
    38                              <1> ;------------------------------------------------------------------------------
    39                              <1> ; @file
    40                              <1> ; Definitions of POST CODES for the reset vector module
    41                              <1> ;
    42                              <1> ; Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
    43                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
    44                              <1> ;
    45                              <1> ;------------------------------------------------------------------------------
    46                              <1> 
    47                              <1> %define POSTCODE_16BIT_MODE     0x16
    48                              <1> %define POSTCODE_32BIT_MODE     0x32
    49                              <1> %define POSTCODE_64BIT_MODE     0x64
    50                              <1> 
    51                              <1> %define POSTCODE_BFV_NOT_FOUND  0xb0
    52                              <1> %define POSTCODE_BFV_FOUND      0xb1
    53                              <1> 
    54                              <1> %define POSTCODE_SEC_NOT_FOUND  0xf0
    55                              <1> %define POSTCODE_SEC_FOUND      0xf1
    56                              <1> 
    38                                  
    39                                  %ifdef DEBUG_PORT80
    40                                    %include "Port80Debug.asm"
    41                                  %elifdef DEBUG_SERIAL
    42                                    %include "SerialDebug.asm"
    43                                  %elif 0
    44                                  ; Set ^ this to 1 to enable postcodes on the qemu debug console.
    45                                  ; Disabled by default because it is incompatible with SEV-ES/SEV-SNP and TDX.
    46                                    %include "QemuDebugCon.asm"
    47                                  %else
    48                                    %include "DebugDisabled.asm"
    49                              <1> ;------------------------------------------------------------------------------
    50                              <1> ; @file
    51                              <1> ; Debug disabled
    52                              <1> ;
    53                              <1> ; Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
    54                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
    55                              <1> ;
    56                              <1> ;------------------------------------------------------------------------------
    57                              <1> 
    58                              <1> BITS    16
    59                              <1> 
    60                              <1> %macro  debugInitialize 0
    61                              <1>     ;
    62                              <1>     ; No initialization is required
    63                              <1>     ;
    64                              <1> %endmacro
    65                              <1> 
    66                              <1> %macro  debugShowPostCode 1
    67                              <1> %endmacro
    68                              <1> 
    49                                  %endif
    50                                  
    51                                  %include "Ia32/SearchForBfvBase.asm"
    52                              <1> ;------------------------------------------------------------------------------
    53                              <1> ; @file
    54                              <1> ; Search for the Boot Firmware Volume (BFV) base address
    55                              <1> ;
    56                              <1> ; Copyright (c) 2008 - 2022, Intel Corporation. All rights reserved.<BR>
    57                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
    58                              <1> ;
    59                              <1> ;------------------------------------------------------------------------------
    60                              <1> 
    61                              <1> ;#define EFI_FIRMWARE_FILE_SYSTEM2_GUID ;  { 0x8c8ce578, 0x8a3d, 0x4f1c, { 0x99, 0x35, 0x89, 0x61, 0x85, 0xc3, 0x2d, 0xd3 } }
    63                              <1> %define FFS2_GUID_DWORD0 0x8c8ce578
    64                              <1> %define FFS2_GUID_DWORD1 0x4f1c8a3d
    65                              <1> %define FFS2_GUID_DWORD2 0x61893599
    66                              <1> %define FFS2_GUID_DWORD3 0xd32dc385
    67                              <1> 
    68                              <1> ;#define EFI_FIRMWARE_FILE_SYSTEM3_GUID ;  { 0x8c8ce578, 0x3dcb, 0x4dca, { 0xbd, 0x6f, 0x1e, 0x96, 0x89, 0xe7, 0x34, 0x9a } }
    70                              <1> %define FFS3_GUID_DWORD0 0x5473c07a
    71                              <1> %define FFS3_GUID_DWORD1 0x4dca3dcb
    72                              <1> %define FFS3_GUID_DWORD2 0x961e6fbd
    73                              <1> %define FFS3_GUID_DWORD3 0x9a34e789
    74                              <1> 
    75                              <1> BITS    32
    76                              <1> 
    77                              <1> ;
    78                              <1> ; Modified:  EAX, EBX
    79                              <1> ; Preserved: EDI, ESP
    80                              <1> ;
    81                              <1> ; @param[out]  EBP  Address of Boot Firmware Volume (BFV)
    82                              <1> ;
    83                              <1> Flat32SearchForBfvBase:
    84                              <1> 
    85 00000000 31C0                <1>     xor     eax, eax
    86                              <1> searchingForBfvHeaderLoop:
    87                              <1>     ;
    88                              <1>     ; We check for a firmware volume at every 4KB address in the top 16MB
    89                              <1>     ; just below 4GB.  (Addresses at 0xffHHH000 where H is any hex digit.)
    90                              <1>     ;
    91 00000002 2D00100000          <1>     sub     eax, 0x1000
    92 00000007 3D000000FF          <1>     cmp     eax, 0xff000000
    93 0000000C 7259                <1>     jb      searchedForBfvHeaderButNotFound
    94                              <1> 
    95                              <1>     ;
    96                              <1>     ; Check FFS3 GUID
    97                              <1>     ;
    98 0000000E 8178107AC07354      <1>     cmp     dword [eax + 0x10], FFS3_GUID_DWORD0
    99 00000015 751D                <1>     jne     searchingForFfs2Guid
   100 00000017 817814CB3DCA4D      <1>     cmp     dword [eax + 0x14], FFS3_GUID_DWORD1
   101 0000001E 7514                <1>     jne     searchingForFfs2Guid
   102 00000020 817818BD6F1E96      <1>     cmp     dword [eax + 0x18], FFS3_GUID_DWORD2
   103 00000027 750B                <1>     jne     searchingForFfs2Guid
   104 00000029 81781C89E7349A      <1>     cmp     dword [eax + 0x1c], FFS3_GUID_DWORD3
   105 00000030 7502                <1>     jne     searchingForFfs2Guid
   106 00000032 EB24                <1>     jmp     checkingFvLength
   107                              <1> 
   108                              <1> searchingForFfs2Guid:
   109                              <1>     ;
   110                              <1>     ; Check FFS2 GUID
   111                              <1>     ;
   112 00000034 81781078E58C8C      <1>     cmp     dword [eax + 0x10], FFS2_GUID_DWORD0
   113 0000003B 75C5                <1>     jne     searchingForBfvHeaderLoop
   114 0000003D 8178143D8A1C4F      <1>     cmp     dword [eax + 0x14], FFS2_GUID_DWORD1
   115 00000044 75BC                <1>     jne     searchingForBfvHeaderLoop
   116 00000046 81781899358961      <1>     cmp     dword [eax + 0x18], FFS2_GUID_DWORD2
   117 0000004D 75B3                <1>     jne     searchingForBfvHeaderLoop
   118 0000004F 81781C85C32DD3      <1>     cmp     dword [eax + 0x1c], FFS2_GUID_DWORD3
   119 00000056 75AA                <1>     jne     searchingForBfvHeaderLoop
   120                              <1> 
   121                              <1> checkingFvLength:
   122                              <1>     ;
   123                              <1>     ; Check FV Length
   124                              <1>     ;
   125 00000058 83782400            <1>     cmp     dword [eax + 0x24], 0
   126 0000005C 75A4                <1>     jne     searchingForBfvHeaderLoop
   127 0000005E 89C3                <1>     mov     ebx, eax
   128 00000060 035820              <1>     add     ebx, dword [eax + 0x20]
   129 00000063 759D                <1>     jnz     searchingForBfvHeaderLoop
   130                              <1> 
   131 00000065 EB09                <1>     jmp     searchedForBfvHeaderAndItWasFound
   132                              <1> 
   133                              <1> searchedForBfvHeaderButNotFound:
   134                              <1>     ;
   135                              <1>     ; Hang if the SEC entry point was not found
   136                              <1>     ;
   137                              <1>     debugShowPostCode POSTCODE_BFV_NOT_FOUND
   138                              <1> 
   139                              <1>     ;
   140                              <1>     ; 0xbfbfbfbf in the EAX & EBP registers helps signal what failed
   141                              <1>     ; for debugging purposes.
   142                              <1>     ;
   143 00000067 B8BFBFBFBF          <1>     mov     eax, 0xBFBFBFBF
   144 0000006C 89C5                <1>     mov     ebp, eax
   145 0000006E EBFE                <1>     jmp     $
   146                              <1> 
   147                              <1> searchedForBfvHeaderAndItWasFound:
   148 00000070 89C5                <1>     mov     ebp, eax
   149                              <1> 
   150                              <1>     debugShowPostCode POSTCODE_BFV_FOUND
   151                              <1> 
   152                              <1>     OneTimeCallRet Flat32SearchForBfvBase
    54 00000072 E9CB090000          <2>  jmp %1 %+ OneTimerCallReturn
   153                              <1> 
    52                                  %include "Ia32/SearchForSecEntry.asm"
    53                              <1> ;------------------------------------------------------------------------------
    54                              <1> ; @file
    55                              <1> ; Search for the SEC Core entry point
    56                              <1> ;
    57                              <1> ; Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
    58                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
    59                              <1> ;
    60                              <1> ;------------------------------------------------------------------------------
    61                              <1> 
    62                              <1> BITS    32
    63                              <1> 
    64                              <1> %define EFI_FV_FILETYPE_SECURITY_CORE         0x03
    65                              <1> 
    66                              <1> ;
    67                              <1> ; Modified:  EAX, EBX, ECX, EDX
    68                              <1> ; Preserved: EDI, EBP, ESP
    69                              <1> ;
    70                              <1> ; @param[in]   EBP  Address of Boot Firmware Volume (BFV)
    71                              <1> ; @param[out]  ESI  SEC Core Entry Point Address
    72                              <1> ;
    73                              <1> Flat32SearchForSecEntryPoint:
    74                              <1> 
    75                              <1>     ;
    76                              <1>     ; Initialize EBP and ESI to 0
    77                              <1>     ;
    78 00000077 31DB                <1>     xor     ebx, ebx
    79 00000079 89DE                <1>     mov     esi, ebx
    80                              <1> 
    81                              <1>     ;
    82                              <1>     ; Pass over the BFV header
    83                              <1>     ;
    84 0000007B 89E8                <1>     mov     eax, ebp
    85 0000007D 668B5D30            <1>     mov     bx, [ebp + 0x30]
    86 00000081 01D8                <1>     add     eax, ebx
    87 00000083 723B                <1>     jc      secEntryPointWasNotFound
    88                              <1> 
    89 00000085 EB03                <1>     jmp     searchingForFfsFileHeaderLoop
    90                              <1> 
    91                              <1> moveForwardWhileSearchingForFfsFileHeaderLoop:
    92                              <1>     ;
    93                              <1>     ; Make forward progress in the search
    94                              <1>     ;
    95 00000087 40                  <1>     inc     eax
    96 00000088 7236                <1>     jc      secEntryPointWasNotFound
    97                              <1> 
    98                              <1> searchingForFfsFileHeaderLoop:
    99 0000008A 85C0                <1>     test    eax, eax
   100 0000008C 7432                <1>     jz      secEntryPointWasNotFound
   101                              <1> 
   102                              <1>     ;
   103                              <1>     ; Ensure 8 byte alignment
   104                              <1>     ;
   105 0000008E 83C007              <1>     add     eax, 7
   106 00000091 722D                <1>     jc      secEntryPointWasNotFound
   107 00000093 24F8                <1>     and     al, 0xf8
   108                              <1> 
   109                              <1>     ;
   110                              <1>     ; Look to see if there is an FFS file at eax
   111                              <1>     ;
   112 00000095 8A5817              <1>     mov     bl, [eax + 0x17]
   113 00000098 F6C320              <1>     test    bl, 0x20
   114 0000009B 74EA                <1>     jz      moveForwardWhileSearchingForFfsFileHeaderLoop
   115 0000009D 8B4814              <1>     mov     ecx, [eax + 0x14]
   116 000000A0 81E1FFFFFF00        <1>     and     ecx, 0x00ffffff
   117 000000A6 09C9                <1>     or      ecx, ecx
   118 000000A8 74DD                <1>     jz      moveForwardWhileSearchingForFfsFileHeaderLoop
   119 000000AA 01C1                <1>     add     ecx, eax
   120 000000AC 7402                <1>     jz      jumpSinceWeFoundTheLastFfsFile
   121 000000AE 72D7                <1>     jc      moveForwardWhileSearchingForFfsFileHeaderLoop
   122                              <1> jumpSinceWeFoundTheLastFfsFile:
   123                              <1> 
   124                              <1>     ;
   125                              <1>     ; There seems to be a valid file at eax
   126                              <1>     ;
   127 000000B0 80781203            <1>     cmp     byte [eax + 0x12], EFI_FV_FILETYPE_SECURITY_CORE ; Check File Type
   128 000000B4 7506                <1>     jne     readyToTryFfsFileAtEcx
   129                              <1> 
   130                              <1> fileTypeIsSecCore:
   131                              <1>     OneTimeCall GetEntryPointOfFfsFile
    49 000000B6 EB17                <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   132 000000B8 85C0                <1>     test    eax, eax
   133 000000BA 7506                <1>     jnz     doneSeachingForSecEntryPoint
   134                              <1> 
   135                              <1> readyToTryFfsFileAtEcx:
   136                              <1>     ;
   137                              <1>     ; Try the next FFS file at ECX
   138                              <1>     ;
   139 000000BC 89C8                <1>     mov     eax, ecx
   140 000000BE EBCA                <1>     jmp     searchingForFfsFileHeaderLoop
   141                              <1> 
   142                              <1> secEntryPointWasNotFound:
   143 000000C0 31C0                <1>     xor     eax, eax
   144                              <1> 
   145                              <1> doneSeachingForSecEntryPoint:
   146 000000C2 89C6                <1>     mov     esi, eax
   147                              <1> 
   148 000000C4 85F6                <1>     test    esi, esi
   149 000000C6 7502                <1>     jnz     secCoreEntryPointWasFound
   150                              <1> 
   151                              <1> secCoreEntryPointWasNotFound:
   152                              <1>     ;
   153                              <1>     ; Hang if the SEC entry point was not found
   154                              <1>     ;
   155                              <1>     debugShowPostCode POSTCODE_SEC_NOT_FOUND
   156 000000C8 74FE                <1>     jz      $
   157                              <1> 
   158                              <1> secCoreEntryPointWasFound:
   159                              <1>     debugShowPostCode POSTCODE_SEC_FOUND
   160                              <1> 
   161                              <1>     OneTimeCallRet Flat32SearchForSecEntryPoint
    54 000000CA E978090000          <2>  jmp %1 %+ OneTimerCallReturn
   162                              <1> 
   163                              <1> %define EFI_SECTION_PE32                  0x10
   164                              <1> %define EFI_SECTION_TE                    0x12
   165                              <1> 
   166                              <1> ;
   167                              <1> ; Input:
   168                              <1> ;   EAX - Start of FFS file
   169                              <1> ;   ECX - End of FFS file
   170                              <1> ;
   171                              <1> ; Output:
   172                              <1> ;   EAX - Entry point of PE32 (or 0 if not found)
   173                              <1> ;
   174                              <1> ; Modified:
   175                              <1> ;   EBX
   176                              <1> ;
   177                              <1> GetEntryPointOfFfsFile:
   178 000000CF 85C0                <1>     test    eax, eax
   179 000000D1 745F                <1>     jz      getEntryPointOfFfsFileErrorReturn
   180 000000D3 83C018              <1>     add     eax, 0x18       ; EAX = Start of section
   181                              <1> 
   182                              <1> getEntryPointOfFfsFileLoopForSections:
   183 000000D6 39C8                <1>     cmp     eax, ecx
   184 000000D8 7358                <1>     jae     getEntryPointOfFfsFileErrorReturn
   185                              <1> 
   186 000000DA 80780310            <1>     cmp     byte [eax + 3], EFI_SECTION_PE32
   187 000000DE 741B                <1>     je      getEntryPointOfFfsFileFoundPe32Section
   188                              <1> 
   189 000000E0 80780312            <1>     cmp     byte [eax + 3], EFI_SECTION_TE
   190 000000E4 7432                <1>     je      getEntryPointOfFfsFileFoundTeSection
   191                              <1> 
   192                              <1>     ;
   193                              <1>     ; The section type was not PE32 or TE, so move to next section
   194                              <1>     ;
   195 000000E6 8B18                <1>     mov     ebx, dword [eax]
   196 000000E8 81E3FFFFFF00        <1>     and     ebx, 0x00ffffff
   197 000000EE 01D8                <1>     add     eax, ebx
   198 000000F0 7240                <1>     jc      getEntryPointOfFfsFileErrorReturn
   199                              <1> 
   200                              <1>     ;
   201                              <1>     ; Ensure that FFS section is 32-bit aligned
   202                              <1>     ;
   203 000000F2 83C003              <1>     add     eax, 3
   204 000000F5 723B                <1>     jc      getEntryPointOfFfsFileErrorReturn
   205 000000F7 24FC                <1>     and     al, 0xfc
   206 000000F9 EBDB                <1>     jmp     getEntryPointOfFfsFileLoopForSections
   207                              <1> 
   208                              <1> getEntryPointOfFfsFileFoundPe32Section:
   209 000000FB 83C004              <1>     add     eax, 4       ; EAX = Start of PE32 image
   210                              <1> 
   211 000000FE 6681384D5A          <1>     cmp     word [eax], 'MZ'
   212 00000103 752D                <1>     jne     getEntryPointOfFfsFileErrorReturn
   213 00000105 0FB7583C            <1>     movzx   ebx, word [eax + 0x3c]
   214 00000109 01C3                <1>     add     ebx, eax
   215                              <1> 
   216                              <1>     ; if (Hdr.Pe32->Signature == EFI_IMAGE_NT_SIGNATURE)
   217 0000010B 813B50450000        <1>     cmp     dword [ebx], `PE\x00\x00`
   218 00000111 751F                <1>     jne     getEntryPointOfFfsFileErrorReturn
   219                              <1> 
   220                              <1>     ; *EntryPoint = (VOID *)((UINTN)Pe32Data +
   221                              <1>     ;   (UINTN)(Hdr.Pe32->OptionalHeader.AddressOfEntryPoint & 0x0ffffffff));
   222 00000113 034328              <1>     add     eax, [ebx + 0x4 + 0x14 + 0x10]
   223 00000116 EB1F                <1>     jmp     getEntryPointOfFfsFileReturn
   224                              <1> 
   225                              <1> getEntryPointOfFfsFileFoundTeSection:
   226 00000118 83C004              <1>     add     eax, 4       ; EAX = Start of TE image
   227 0000011B 89C3                <1>     mov     ebx, eax
   228                              <1> 
   229                              <1>     ; if (Hdr.Te->Signature == EFI_TE_IMAGE_HEADER_SIGNATURE)
   230 0000011D 66813B565A          <1>     cmp     word [ebx], 'VZ'
   231 00000122 750E                <1>     jne     getEntryPointOfFfsFileErrorReturn
   232                              <1>     ; *EntryPoint = (VOID *)((UINTN)Pe32Data +
   233                              <1>     ;   (UINTN)(Hdr.Te->AddressOfEntryPoint & 0x0ffffffff) +
   234                              <1>     ;   sizeof(EFI_TE_IMAGE_HEADER) - Hdr.Te->StrippedSize);
   235 00000124 034308              <1>     add     eax, [ebx + 0x8]
   236 00000127 83C028              <1>     add     eax, 0x28
   237 0000012A 0FB75B06            <1>     movzx   ebx, word [ebx + 0x6]
   238 0000012E 29D8                <1>     sub     eax, ebx
   239 00000130 EB05                <1>     jmp     getEntryPointOfFfsFileReturn
   240                              <1> 
   241                              <1> getEntryPointOfFfsFileErrorReturn:
   242 00000132 B800000000          <1>     mov     eax, 0
   243                              <1> 
   244                              <1> getEntryPointOfFfsFileReturn:
   245                              <1>     OneTimeCallRet GetEntryPointOfFfsFile
    54 00000137 E97CFFFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   246                              <1> 
    53                                  
    54                                  %define WORK_AREA_GUEST_TYPE (00080B000h)
    55                                  %define PT_ADDR(Offset) (000800000h + (Offset))
    56                                  %define PG_5_LEVEL (0)
    57                                  
    58                                  %define GHCB_PT_ADDR (000808000h)
    59                                  %define GHCB_BASE (000809000h)
    60                                  %define GHCB_SIZE (000002000h)
    61                                  %define SEV_ES_WORK_AREA (8433668)
    62                                  %define SEV_ES_WORK_AREA_SIZE 25
    63                                  %define SEV_ES_WORK_AREA_STATUS_MSR (8433668)
    64                                  %define SEV_ES_WORK_AREA_RDRAND (8433668 + 8)
    65                                  %define SEV_ES_WORK_AREA_ENC_MASK (8433668 + 16)
    66                                  %define SEV_ES_WORK_AREA_RECEIVED_VC (8433668 + 24)
    67                                  %define SEV_ES_VC_TOP_OF_STACK (000811000h + 00000F000h)
    68                                  %define SEV_SNP_SECRETS_BASE (00080D000h)
    69                                  %define SEV_SNP_SECRETS_SIZE (000001000h)
    70                                  %define CPUID_BASE (00080E000h)
    71                                  %define CPUID_SIZE (000001000h)
    72                                  %define SVSM_CAA_BASE (00080F000h)
    73                                  %define SVSM_CAA_SIZE (000001000h)
    74                                  %if (00h > 0)
    75                                    ; There's a reserved page for SEV secrets and hashes; the VMM will fill and
    76                                    ; validate the page, or mark it as a zero page.
    77                                    %define SEV_SNP_KERNEL_HASHES_BASE (00h)
    78                                    %define SEV_SNP_KERNEL_HASHES_SIZE (00h + 00h)
    79                                  %else
    80                                    %define SEV_SNP_KERNEL_HASHES_BASE 0
    81                                    %define SEV_SNP_KERNEL_HASHES_SIZE 0
    82                                  %endif
    83                                  %define SNP_SEC_MEM_BASE_DESC_1 (000800000h)
    84                                  %define SNP_SEC_MEM_SIZE_DESC_1 (000809000h - SNP_SEC_MEM_BASE_DESC_1)
    85                                  ;
    86                                  ; The PcdOvmfSecGhcbBase reserves two GHCB pages. The first page is used
    87                                  ; as GHCB shared page and second is used for bookkeeping to support the
    88                                  ; nested GHCB in SEC phase. The bookkeeping page is mapped private. The VMM
    89                                  ; does not need to validate the shared page but it need to validate the
    90                                  ; bookkeeping page.
    91                                  ;
    92                                  %define SNP_SEC_MEM_BASE_DESC_2 (GHCB_BASE + 01000h)
    93                                  %define SNP_SEC_MEM_SIZE_DESC_2 (SEV_SNP_SECRETS_BASE - SNP_SEC_MEM_BASE_DESC_2)
    94                                  %define SNP_SEC_MEM_BASE_DESC_3 (SVSM_CAA_BASE + SVSM_CAA_SIZE + SEV_SNP_KERNEL_HASHES_SIZE)
    95                                  %define SNP_SEC_MEM_SIZE_DESC_3 (000820000h - SNP_SEC_MEM_BASE_DESC_3)
    96                                  
    97                                  %ifdef ARCH_X64
    98                                  
    99                                  
   100                                    %if (000006000h != 06000h)
   101                                      %error "This implementation inherently depends on PcdOvmfSecPageTablesSize"
   102                                    %endif
   103                                  
   104                                    %if (000001000h != 01000h)
   105                                      %error "This implementation inherently depends on PcdOvmfSecGhcbPageTableSize"
   106                                    %endif
   107                                  
   108                                    %if (000002000h != 02000h)
   109                                      %error "This implementation inherently depends on PcdOvmfSecGhcbSize"
   110                                    %endif
   111                                  
   112                                    %if ((000809000h >> 21) != ((000809000h + 000002000h - 1) >> 21))
   113                                  
   114                                      %error "This implementation inherently depends on PcdOvmfSecGhcbBase not straddling a 2MB boundary"
   115                                    %endif
   116                                  
   117                                    %define TDX_BFV_RAW_DATA_OFFSET 084000h
   118                                    %define TDX_BFV_RAW_DATA_SIZE 00037C000h
   119                                    %define TDX_BFV_MEMORY_BASE 0FFC84000h
   120                                    %define TDX_BFV_MEMORY_SIZE 00037C000h
   121                                  
   122                                    %define TDX_CFV_RAW_DATA_OFFSET 0
   123                                    %define TDX_CFV_RAW_DATA_SIZE 084000h
   124                                    %define TDX_CFV_MEMORY_BASE 0FFC00000h,
   125                                    %define TDX_CFV_MEMORY_SIZE 084000h,
   126                                  
   127                                    %define TDX_HEAP_STACK_BASE 000811000h
   128                                    %define TDX_HEAP_STACK_SIZE 00000F000h
   129                                  
   130                                    %define TDX_HOB_MEMORY_BASE 000809000h
   131                                    %define TDX_HOB_MEMORY_SIZE 000002000h
   132                                  
   133                                    %define TDX_INIT_MEMORY_BASE 00080B000h
   134                                    %define TDX_INIT_MEMORY_SIZE (000001000h + 000001000h)
   135                                  
   136                                    %define OVMF_PAGE_TABLE_BASE 000800000h
   137                                    %define OVMF_PAGE_TABLE_SIZE 000006000h
   138                                  
   139                                    %define TDX_WORK_AREA_PGTBL_READY (00080B000h + 4)
   140                                    %define TDX_WORK_AREA_GPAW (00080B000h + 8)
   141                                  
   142                                    %include "X64/IntelTdxMetadata.asm"
   143                              <1> ;------------------------------------------------------------------------------
   144                              <1> ; @file
   145                              <1> ; Tdx Virtual Firmware metadata
   146                              <1> ;
   147                              <1> ; When host VMM creates a new guest TD, some initial set of TD-private pages
   148                              <1> ; are added using the TDH.MEM.PAGE.ADD function. These pages typically contain
   149                              <1> ; Virtual BIOS code and data along with some clear pages for stacks and heap.
   150                              <1> ; In the meanwhile, some configuration data need be measured by host VMM.
   151                              <1> ; Tdx Metadata is designed for this purpose to indicate host VMM how to do the
   152                              <1> ; above tasks.
   153                              <1> ;
   154                              <1> ; Tdx Metadata consists of a DESCRIPTOR as the header followed by several
   155                              <1> ; SECTIONs. Host VMM sets up the memory for TDVF according to these sections.
   156                              <1> ;
   157                              <1> ; _Bfv is the example (Bfv refers to the Virtual BIOS code).
   158                              <1> ; - By DataOffset/RawDataSize host VMM knows about the position of the code
   159                              <1> ;   in the binary image.
   160                              <1> ; - MemoryAddress/MemoryDataSize indicates the guest physical address/size of
   161                              <1> ;   the Bfv to be loaded.
   162                              <1> ; - Type field means this section is of BFV. This field is designed for the
   163                              <1> ;   purpose that in some case host VMM may do some additional processing based
   164                              <1> ;   upon the section type. TdHob section is an example. Host VMM pass the
   165                              <1> ;   physical memory information to the guest firmware by writing the data in
   166                              <1> ;   the memory region designated by TdHob section.
   167                              <1> ; - By design code part of the binary image (Bfv) should be measured by host
   168                              <1> ;   VMM. This is indicated by the Attributes field.
   169                              <1> ;
   170                              <1> ; So put all these information together, when a new guest is being created,
   171                              <1> ; the initial TD-private pages for BFV is added by TDH.MEM.PAGE.ADD function,
   172                              <1> ; and Bfv is loaded at the guest physical address indicated by MemoryAddress.
   173                              <1> ; Since the Attributes is TDX_METADATA_ATTRIBUTES_EXTENDMR, Bfv is measured by
   174                              <1> ; host VMM.
   175                              <1> ;
   176                              <1> ; Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
   177                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   178                              <1> ;
   179                              <1> ;------------------------------------------------------------------------------
   180                              <1> 
   181                              <1> BITS    64
   182                              <1> 
   183                              <1> %define TDX_METADATA_SECTION_TYPE_BFV       0
   184                              <1> %define TDX_METADATA_SECTION_TYPE_CFV       1
   185                              <1> %define TDX_METADATA_SECTION_TYPE_TD_HOB    2
   186                              <1> %define TDX_METADATA_SECTION_TYPE_TEMP_MEM  3
   187                              <1> %define TDX_METADATA_VERSION                1
   188                              <1> %define TDX_METADATA_ATTRIBUTES_EXTENDMR    0x00000001
   189                              <1> 
   190 0000013C 90<rep 4h>          <1> ALIGN   16
   191                              <1> TIMES (15 - ((TdxGuidedStructureEnd - TdxGuidedStructureStart + 15) % 16)) DB 0
   192                              <1> 
   193                              <1> TdxGuidedStructureStart:
   194                              <1> 
   195                              <1> ;
   196                              <1> ; TDVF meta data
   197                              <1> ;
   198                              <1> TdxMetadataGuid:
   199 00000140 F3F9EAE98E16D544    <1>   DB  0xf3, 0xf9, 0xea, 0xe9, 0x8e, 0x16, 0xd5, 0x44
   200 00000148 A8EB7F4D8738F6AE    <1>   DB  0xa8, 0xeb, 0x7f, 0x4d, 0x87, 0x38, 0xf6, 0xae
   201                              <1> 
   202                              <1> _Descriptor:
   203 00000150 54445646            <1>   DB 'T','D','V','F'                                  ; Signature
   204 00000154 D0000000            <1>   DD TdxGuidedStructureEnd - _Descriptor              ; Length
   205 00000158 01000000            <1>   DD TDX_METADATA_VERSION                             ; Version
   206 0000015C 06000000            <1>   DD (TdxGuidedStructureEnd - _Descriptor - 16)/32    ; Number of sections
   207                              <1> 
   208                              <1> _Bfv:
   209 00000160 00400800            <1>   DD TDX_BFV_RAW_DATA_OFFSET
   210 00000164 00C03700            <1>   DD TDX_BFV_RAW_DATA_SIZE
   211 00000168 0040C8FF00000000    <1>   DQ TDX_BFV_MEMORY_BASE
   212 00000170 00C0370000000000    <1>   DQ TDX_BFV_MEMORY_SIZE
   213 00000178 00000000            <1>   DD TDX_METADATA_SECTION_TYPE_BFV
   214 0000017C 01000000            <1>   DD TDX_METADATA_ATTRIBUTES_EXTENDMR
   215                              <1> 
   216                              <1> _Cfv:
   217 00000180 00000000            <1>   DD TDX_CFV_RAW_DATA_OFFSET
   218 00000184 00400800            <1>   DD TDX_CFV_RAW_DATA_SIZE
   219 00000188 0000C0FF00000000    <1>   DQ TDX_CFV_MEMORY_BASE
   220 00000190 0040080000000000    <1>   DQ TDX_CFV_MEMORY_SIZE
   221 00000198 01000000            <1>   DD TDX_METADATA_SECTION_TYPE_CFV
   222 0000019C 00000000            <1>   DD 0
   223                              <1> 
   224                              <1> _TdxHeapStack:
   225 000001A0 00000000            <1>   DD 0
   226 000001A4 00000000            <1>   DD 0
   227 000001A8 0010810000000000    <1>   DQ TDX_HEAP_STACK_BASE
   228 000001B0 00F0000000000000    <1>   DQ TDX_HEAP_STACK_SIZE
   229 000001B8 03000000            <1>   DD TDX_METADATA_SECTION_TYPE_TEMP_MEM
   230 000001BC 00000000            <1>   DD 0
   231                              <1> 
   232                              <1> _TdxInitMem:
   233 000001C0 00000000            <1>   DD 0
   234 000001C4 00000000            <1>   DD 0
   235 000001C8 00B0800000000000    <1>   DQ TDX_INIT_MEMORY_BASE
   236 000001D0 0020000000000000    <1>   DQ TDX_INIT_MEMORY_SIZE
   237 000001D8 03000000            <1>   DD TDX_METADATA_SECTION_TYPE_TEMP_MEM
   238 000001DC 00000000            <1>   DD 0
   239                              <1> 
   240                              <1> _TdHob:
   241 000001E0 00000000            <1>   DD 0
   242 000001E4 00000000            <1>   DD 0
   243 000001E8 0090800000000000    <1>   DQ TDX_HOB_MEMORY_BASE
   244 000001F0 0020000000000000    <1>   DQ TDX_HOB_MEMORY_SIZE
   245 000001F8 02000000            <1>   DD TDX_METADATA_SECTION_TYPE_TD_HOB
   246 000001FC 00000000            <1>   DD 0
   247                              <1> 
   248                              <1> _OvmfPageTable:
   249 00000200 00000000            <1>   DD 0
   250 00000204 00000000            <1>   DD 0
   251 00000208 0000800000000000    <1>   DQ OVMF_PAGE_TABLE_BASE
   252 00000210 0060000000000000    <1>   DQ OVMF_PAGE_TABLE_SIZE
   253 00000218 03000000            <1>   DD TDX_METADATA_SECTION_TYPE_TEMP_MEM
   254 0000021C 00000000            <1>   DD 0
   255                              <1> 
   256                              <1> TdxGuidedStructureEnd:
   257                              <1> ALIGN   16
   143                                    %include "Ia32/Flat32ToFlat64.asm"
   144                              <1> ;------------------------------------------------------------------------------
   145                              <1> ; @file
   146                              <1> ; Transition from 32 bit flat protected mode into 64 bit flat protected mode
   147                              <1> ;
   148                              <1> ; Copyright (c) 2008 - 2018, Intel Corporation. All rights reserved.<BR>
   149                              <1> ; Copyright (c) 2020, Advanced Micro Devices, Inc. All rights reserved.<BR>
   150                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   151                              <1> ;
   152                              <1> ;------------------------------------------------------------------------------
   153                              <1> 
   154                              <1> BITS    32
   155                              <1> 
   156                              <1> ;
   157                              <1> ; Modified:  EAX, ECX, EDX
   158                              <1> ;
   159                              <1> Transition32FlatTo64Flat:
   160                              <1> 
   161                              <1>     OneTimeCall SetCr3ForPageTables64
    49 00000220 E989000000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   162                              <1> 
   163 00000225 0F20E0              <1>     mov     eax, cr4
   164 00000228 0FBAE805            <1>     bts     eax, 5                      ; enable PAE
   165 0000022C 0F22E0              <1>     mov     cr4, eax
   166                              <1> 
   167                              <1>     ;
   168                              <1>     ; In TDX LME has already been set. So we're done and jump to enable
   169                              <1>     ; paging directly if Tdx is enabled.
   170                              <1>     ; EBX is cleared because in the later it will be used to check if
   171                              <1>     ; the second step of the SEV-ES mitigation is to be performed.
   172                              <1>     ;
   173 0000022F 31DB                <1>     xor     ebx, ebx
   174                              <1>     OneTimeCall IsTdxEnabled
    49 00000231 E96B030000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   175 00000236 85C0                <1>     test    eax, eax
   176 00000238 7538                <1>     jnz     EnablePaging
   177                              <1> 
   178 0000023A B9800000C0          <1>     mov     ecx, 0xc0000080
   179 0000023F 0F32                <1>     rdmsr
   180 00000241 0FBAE808            <1>     bts     eax, 8                      ; set LME
   181 00000245 0F30                <1>     wrmsr
   182                              <1> 
   183                              <1>     ;
   184                              <1>     ; SEV-ES mitigation check support
   185                              <1>     ;
   186 00000247 31DB                <1>     xor     ebx, ebx
   187                              <1> 
   188 00000249 B901000000          <1>     mov     ecx, 1
   189 0000024E 0FA30D04B08000      <1>     bt      [SEV_ES_WORK_AREA_STATUS_MSR], ecx
   190 00000255 731B                <1>     jnc     EnablePaging
   191                              <1> 
   192                              <1>     ;
   193                              <1>     ; SEV-ES is active, perform a quick sanity check against the reported
   194                              <1>     ; encryption bit position. This is to help mitigate against attacks where
   195                              <1>     ; the hypervisor reports an incorrect encryption bit position.
   196                              <1>     ;
   197                              <1>     ; This is the first step in a two step process. Before paging is enabled
   198                              <1>     ; writes to memory are encrypted. Using the RDRAND instruction (available
   199                              <1>     ; on all SEV capable processors), write 64-bits of random data to the
   200                              <1>     ; SEV_ES_WORK_AREA and maintain the random data in registers (register
   201                              <1>     ; state is protected under SEV-ES). This will be used in the second step.
   202                              <1>     ;
   203                              <1> RdRand1:
   204 00000257 0FC7F1              <1>     rdrand  ecx
   205 0000025A 73FB                <1>     jnc     RdRand1
   206 0000025C 890D0CB08000        <1>     mov     dword[SEV_ES_WORK_AREA_RDRAND], ecx
   207                              <1> RdRand2:
   208 00000262 0FC7F2              <1>     rdrand  edx
   209 00000265 73FB                <1>     jnc     RdRand2
   210 00000267 891510B08000        <1>     mov     dword[SEV_ES_WORK_AREA_RDRAND + 4], edx
   211                              <1> 
   212                              <1>     ;
   213                              <1>     ; Use EBX instead of the SEV_ES_WORK_AREA memory to determine whether to
   214                              <1>     ; perform the second step.
   215                              <1>     ;
   216 0000026D BB01000000          <1>     mov     ebx, 1
   217                              <1> 
   218                              <1> EnablePaging:
   219 00000272 0F20C0              <1>     mov     eax, cr0
   220 00000275 0FBAE81F            <1>     bts     eax, 31                     ; set PG
   221 00000279 0F22C0              <1>     mov     cr0, eax                    ; enable paging
   222                              <1> 
   223 0000027C EA73F7FFFF3800      <1>     jmp     LINEAR_CODE64_SEL:ADDR_OF(jumpTo64BitAndLandHere)
   224                              <1> BITS    64
   225                              <1> jumpTo64BitAndLandHere:
   226                              <1> 
   227                              <1>     ;
   228                              <1>     ; Check if the second step of the SEV-ES mitigation is to be performed.
   229                              <1>     ;
   230 00000283 85DB                <1>     test    ebx, ebx
   231 00000285 7412                <1>     jz      InsnCompare
   232                              <1> 
   233                              <1>     ;
   234                              <1>     ; SEV-ES is active, perform the second step of the encryption bit postion
   235                              <1>     ; mitigation check. The ECX and EDX register contain data from RDRAND that
   236                              <1>     ; was stored to memory in encrypted form. If the encryption bit position is
   237                              <1>     ; valid, the contents of ECX and EDX will match the memory location.
   238                              <1>     ;
   239 00000287 390C250CB08000      <1>     cmp     dword[SEV_ES_WORK_AREA_RDRAND], ecx
   240 0000028E 7515                <1>     jne     SevEncBitHlt
   241 00000290 39142510B08000      <1>     cmp     dword[SEV_ES_WORK_AREA_RDRAND + 4], edx
   242 00000297 750C                <1>     jne     SevEncBitHlt
   243                              <1> 
   244                              <1>     ;
   245                              <1>     ; If SEV or SEV-ES is active, perform a quick sanity check against
   246                              <1>     ; the reported encryption bit position. This is to help mitigate
   247                              <1>     ; against attacks where the hypervisor reports an incorrect encryption
   248                              <1>     ; bit position. If SEV is not active, this check will always succeed.
   249                              <1>     ;
   250                              <1>     ; The cmp instruction compares the first four bytes of the cmp instruction
   251                              <1>     ; itself (which will be read decrypted if SEV or SEV-ES is active and the
   252                              <1>     ; encryption bit position is valid) against the immediate within the
   253                              <1>     ; instruction (an instruction fetch is always decrypted correctly by
   254                              <1>     ; hardware) based on RIP relative addressing.
   255                              <1>     ;
   256                              <1> InsnCompare:
   257 00000299 813DF6FFFFFF813DF6- <1>     cmp     dword[rel InsnCompare], 0xFFF63D81
   257 000002A2 FF                  <1>
   258 000002A3 7404                <1>     je      GoodCompare
   259                              <1> 
   260                              <1>     ;
   261                              <1>     ; The hypervisor provided an incorrect encryption bit position, do not
   262                              <1>     ; proceed.
   263                              <1>     ;
   264                              <1> SevEncBitHlt:
   265 000002A5 FA                  <1>     cli
   266 000002A6 F4                  <1>     hlt
   267 000002A7 EBFC                <1>     jmp     SevEncBitHlt
   268                              <1> 
   269                              <1> GoodCompare:
   270                              <1>     debugShowPostCode POSTCODE_64BIT_MODE
   271                              <1> 
   272                              <1>     OneTimeCallRet Transition32FlatTo64Flat
    54 000002A9 E99E070000          <2>  jmp %1 %+ OneTimerCallReturn
   273                              <1> 
   144                                    %include "Ia32/PageTables64.asm"
   145                              <1> ;------------------------------------------------------------------------------
   146                              <1> ; @file
   147                              <1> ; Sets the CR3 register for 64-bit paging
   148                              <1> ;
   149                              <1> ; Copyright (c) 2008 - 2013, Intel Corporation. All rights reserved.<BR>
   150                              <1> ; Copyright (c) 2017 - 2020, Advanced Micro Devices, Inc. All rights reserved.<BR>
   151                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   152                              <1> ;
   153                              <1> ;------------------------------------------------------------------------------
   154                              <1> 
   155                              <1> BITS    32
   156                              <1> 
   157                              <1> ; common for all levels
   158                              <1> %define PAGE_PRESENT            0x01
   159                              <1> %define PAGE_READ_WRITE         0x02
   160                              <1> %define PAGE_USER_SUPERVISOR    0x04
   161                              <1> %define PAGE_WRITE_THROUGH      0x08
   162                              <1> %define PAGE_CACHE_DISABLE     0x010
   163                              <1> %define PAGE_ACCESSED          0x020
   164                              <1> %define PAGE_DIRTY             0x040
   165                              <1> %define PAGE_GLOBAL           0x0100
   166                              <1> 
   167                              <1> ; page table entries (level 1)
   168                              <1> %define PAGE_PTE_PAT           0x080
   169                              <1> 
   170                              <1> ; page directory entries (level 2+)
   171                              <1> %define PAGE_PDE_LARGEPAGE     0x080
   172                              <1> %define PAGE_PDE_PAT         0x01000
   173                              <1> 
   174                              <1> %define PAGE_4K_PDE_ATTR (PAGE_ACCESSED +                           PAGE_DIRTY +                           PAGE_READ_WRITE +                           PAGE_PRESENT)
   178                              <1> 
   179                              <1> %define PAGE_PDE_LARGEPAGE_ATTR (PAGE_PDE_LARGEPAGE +                                  PAGE_ACCESSED +                                  PAGE_DIRTY +                                  PAGE_READ_WRITE +                                  PAGE_PRESENT)
   184                              <1> 
   185                              <1> %define PAGE_PDE_DIRECTORY_ATTR (PAGE_ACCESSED +                                  PAGE_READ_WRITE +                                  PAGE_PRESENT)
   188                              <1> 
   189                              <1> %define TDX_BSP         1
   190                              <1> %define TDX_AP          2
   191                              <1> %define TDX_AP_5_LEVEL  3
   192                              <1> 
   193                              <1> ;
   194                              <1> ; For OVMF, build some initial page tables at
   195                              <1> ; PcdOvmfSecPageTablesBase - (PcdOvmfSecPageTablesBase + 0x6000).
   196                              <1> ;
   197                              <1> ; This range should match with PcdOvmfSecPageTablesSize which is
   198                              <1> ; declared in the FDF files.
   199                              <1> ;
   200                              <1> ; At the end of PEI, the pages tables will be rebuilt into a
   201                              <1> ; more permanent location by DxeIpl.
   202                              <1> ;
   203                              <1> %macro ClearOvmfPageTables 0
   204                              <1>     mov     ecx, 6 * 0x1000 / 4
   205                              <1>     xor     eax, eax
   206                              <1> .clearPageTablesMemoryLoop:
   207                              <1>     mov     dword[ecx * 4 + PT_ADDR (0) - 4], eax
   208                              <1>     loop    .clearPageTablesMemoryLoop
   209                              <1> %endmacro
   210                              <1> 
   211                              <1> ;
   212                              <1> ; Create page tables for 4-level paging
   213                              <1> ;
   214                              <1> ; Argument: upper 32 bits of the leaf page table entries
   215                              <1> ;
   216                              <1> %macro CreatePageTables4Level 1
   217                              <1> 
   218                              <1>     ; indicate 4-level paging
   219                              <1>     debugShowPostCode 0x41
   220                              <1> 
   221                              <1>     ;
   222                              <1>     ; Top level Page Directory Pointers (1 * 512GB entry)
   223                              <1>     ;
   224                              <1>     mov     dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDE_DIRECTORY_ATTR
   225                              <1>     mov     dword[PT_ADDR (4)], 0
   226                              <1> 
   227                              <1>     ;
   228                              <1>     ; Next level Page Directory Pointers (4 * 1GB entries => 4GB)
   229                              <1>     ;
   230                              <1>     mov     dword[PT_ADDR (0x1000)], PT_ADDR (0x2000) + PAGE_PDE_DIRECTORY_ATTR
   231                              <1>     mov     dword[PT_ADDR (0x1004)], 0
   232                              <1>     mov     dword[PT_ADDR (0x1008)], PT_ADDR (0x3000) + PAGE_PDE_DIRECTORY_ATTR
   233                              <1>     mov     dword[PT_ADDR (0x100C)], 0
   234                              <1>     mov     dword[PT_ADDR (0x1010)], PT_ADDR (0x4000) + PAGE_PDE_DIRECTORY_ATTR
   235                              <1>     mov     dword[PT_ADDR (0x1014)], 0
   236                              <1>     mov     dword[PT_ADDR (0x1018)], PT_ADDR (0x5000) + PAGE_PDE_DIRECTORY_ATTR
   237                              <1>     mov     dword[PT_ADDR (0x101C)], 0
   238                              <1> 
   239                              <1>     ;
   240                              <1>     ; Page Table Entries (2048 * 2MB entries => 4GB)
   241                              <1>     ;
   242                              <1>     mov     ecx, 0x800
   243                              <1> .pageTableEntriesLoop4Level:
   244                              <1>     mov     eax, ecx
   245                              <1>     dec     eax
   246                              <1>     shl     eax, 21
   247                              <1>     add     eax, PAGE_PDE_LARGEPAGE_ATTR
   248                              <1>     mov     dword[ecx * 8 + PT_ADDR (0x2000 - 8)], eax
   249                              <1>     mov     dword[(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], %1
   250                              <1>     loop    .pageTableEntriesLoop4Level
   251                              <1> %endmacro
   252                              <1> 
   253                              <1> ;
   254                              <1> ; Check whenever 5-level paging can be used
   255                              <1> ;
   256                              <1> ; Argument: jump label for 4-level paging
   257                              <1> ;
   258                              <1> %macro Check5LevelPaging 1
   259                              <1>     ; check for cpuid leaf 0x07
   260                              <1>     mov     eax, 0x00
   261                              <1>     cpuid
   262                              <1>     cmp     eax, 0x07
   263                              <1>     jb      %1
   264                              <1> 
   265                              <1>     ; check for la57 (aka 5-level paging)
   266                              <1>     mov     eax, 0x07
   267                              <1>     mov     ecx, 0x00
   268                              <1>     cpuid
   269                              <1>     bt      ecx, 16
   270                              <1>     jnc     %1
   271                              <1> 
   272                              <1>     ; check for cpuid leaf 0x80000001
   273                              <1>     mov     eax, 0x80000000
   274                              <1>     cpuid
   275                              <1>     cmp     eax, 0x80000001
   276                              <1>     jb      %1
   277                              <1> 
   278                              <1>     ; check for 1g pages
   279                              <1>     mov     eax, 0x80000001
   280                              <1>     cpuid
   281                              <1>     bt      edx, 26
   282                              <1>     jnc     %1
   283                              <1> %endmacro
   284                              <1> 
   285                              <1> ;
   286                              <1> ; Create page tables for 5-level paging with gigabyte pages
   287                              <1> ;
   288                              <1> ; Argument: upper 32 bits of the leaf page table entries
   289                              <1> ;
   290                              <1> ; We have 6 pages available for the early page tables,
   291                              <1> ; we use four of them:
   292                              <1> ;    PT_ADDR(0)      - level 5 directory
   293                              <1> ;    PT_ADDR(0x1000) - level 4 directory
   294                              <1> ;    PT_ADDR(0x2000) - level 2 directory (0 -> 1GB)
   295                              <1> ;    PT_ADDR(0x3000) - level 3 directory
   296                              <1> ;
   297                              <1> ; The level 2 directory for the first gigabyte has the same
   298                              <1> ; physical address in both 4-level and 5-level paging mode,
   299                              <1> ; SevClearPageEncMaskForGhcbPage depends on this.
   300                              <1> ;
   301                              <1> ; The 1 GB -> 4 GB range is mapped using 1G pages in the
   302                              <1> ; level 3 directory.
   303                              <1> ;
   304                              <1> %macro CreatePageTables5Level 1
   305                              <1> 
   306                              <1>     ; indicate 5-level paging
   307                              <1>     debugShowPostCode 0x51
   308                              <1> 
   309                              <1>     ; level 5
   310                              <1>     mov     dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDE_DIRECTORY_ATTR
   311                              <1>     mov     dword[PT_ADDR (4)], 0
   312                              <1> 
   313                              <1>     ; level 4
   314                              <1>     mov     dword[PT_ADDR (0x1000)], PT_ADDR (0x3000) + PAGE_PDE_DIRECTORY_ATTR
   315                              <1>     mov     dword[PT_ADDR (0x1004)], 0
   316                              <1> 
   317                              <1>     ; level 3 (1x -> level 2, 3x 1GB)
   318                              <1>     mov     dword[PT_ADDR (0x3000)], PT_ADDR (0x2000) + PAGE_PDE_DIRECTORY_ATTR
   319                              <1>     mov     dword[PT_ADDR (0x3004)], 0
   320                              <1>     mov     dword[PT_ADDR (0x3008)], (1 << 30) + PAGE_PDE_LARGEPAGE_ATTR
   321                              <1>     mov     dword[PT_ADDR (0x300c)], %1
   322                              <1>     mov     dword[PT_ADDR (0x3010)], (2 << 30) + PAGE_PDE_LARGEPAGE_ATTR
   323                              <1>     mov     dword[PT_ADDR (0x3014)], %1
   324                              <1>     mov     dword[PT_ADDR (0x3018)], (3 << 30) + PAGE_PDE_LARGEPAGE_ATTR
   325                              <1>     mov     dword[PT_ADDR (0x301c)], %1
   326                              <1> 
   327                              <1>     ;
   328                              <1>     ; level 2 (512 * 2MB entries => 1GB)
   329                              <1>     ;
   330                              <1>     mov     ecx, 0x200
   331                              <1> .pageTableEntriesLoop5Level:
   332                              <1>     mov     eax, ecx
   333                              <1>     dec     eax
   334                              <1>     shl     eax, 21
   335                              <1>     add     eax, PAGE_PDE_LARGEPAGE_ATTR
   336                              <1>     mov     dword[ecx * 8 + PT_ADDR (0x2000 - 8)], eax
   337                              <1>     mov     dword[(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], %1
   338                              <1>     loop    .pageTableEntriesLoop5Level
   339                              <1> %endmacro
   340                              <1> 
   341                              <1> %macro Enable5LevelPaging 0
   342                              <1>     ; set la57 bit in cr4
   343                              <1>     mov     eax, cr4
   344                              <1>     bts     eax, 12
   345                              <1>     mov     cr4, eax
   346                              <1> %endmacro
   347                              <1> 
   348                              <1> ;
   349                              <1> ; Modified:  EAX, EBX, ECX, EDX
   350                              <1> ;
   351                              <1> SetCr3ForPageTables64:
   352                              <1>     ; Check the TDX features.
   353                              <1>     ; If it is TDX APs, then jump to SetCr3 directly.
   354                              <1>     ; In TD guest the initialization is done by BSP, including building
   355                              <1>     ; the page tables. APs will spin on until byte[TDX_WORK_AREA_PGTBL_READY]
   356                              <1>     ; is set.
   357                              <1>     OneTimeCall   CheckTdxFeaturesBeforeBuildPagetables
    49 000002AE E9CA020000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   358 000002B3 83F801              <1>     cmp       eax, TDX_BSP
   359 000002B6 0F845B010000        <1>     je        TdxBspInit
   360 000002BC 83F802              <1>     cmp       eax, TDX_AP
   361 000002BF 0F84F1010000        <1>     je        SetCr3
   362                              <1> %if PG_5_LEVEL
   363                              <1>     cmp       eax, TDX_AP_5_LEVEL
   364                              <1>     jne       CheckForSev
   365                              <1>     Enable5LevelPaging
   366                              <1>     jmp       SetCr3
   367                              <1> CheckForSev:
   368                              <1> %endif
   369                              <1> 
   370                              <1>     ; Check whether the SEV is active and populate the SevEsWorkArea
   371                              <1>     OneTimeCall   CheckSevFeatures
    49 000002C5 E9E0030000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   372 000002CA 803D00B0800001      <1>     cmp       byte[WORK_AREA_GUEST_TYPE], 1
   373 000002D1 0F849D000000        <1>     jz        SevInit
   374                              <1> 
   375                              <1>     ;
   376                              <1>     ; normal (non-CoCo) workflow
   377                              <1>     ;
   378                              <1>     ClearOvmfPageTables
   204 000002D7 B900180000          <2>  mov ecx, 6 * 0x1000 / 4
   205 000002DC 31C0                <2>  xor eax, eax
   206                              <2> .clearPageTablesMemoryLoop:
   207 000002DE 89048DFCFF7F00      <2>  mov dword[ecx * 4 + PT_ADDR (0) - 4], eax
   208 000002E5 E2F7                <2>  loop .clearPageTablesMemoryLoop
   379                              <1> %if PG_5_LEVEL
   380                              <1>     Check5LevelPaging Paging4Level
   381                              <1>     CreatePageTables5Level 0
   382                              <1>     Enable5LevelPaging
   383                              <1>     jmp SetCr3
   384                              <1> Paging4Level:
   385                              <1> %endif
   386                              <1>     CreatePageTables4Level 0
   217                              <2> 
   218                              <2> 
   219                              <2>  debugShowPostCode 0x41
   220                              <2> 
   221                              <2> 
   222                              <2> 
   223                              <2> 
   224 000002E7 C70500008000231080- <2>  mov dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDE_DIRECTORY_ATTR
   224 000002F0 00                  <2>
   225 000002F1 C70504008000000000- <2>  mov dword[PT_ADDR (4)], 0
   225 000002FA 00                  <2>
   226                              <2> 
   227                              <2> 
   228                              <2> 
   229                              <2> 
   230 000002FB C70500108000232080- <2>  mov dword[PT_ADDR (0x1000)], PT_ADDR (0x2000) + PAGE_PDE_DIRECTORY_ATTR
   230 00000304 00                  <2>
   231 00000305 C70504108000000000- <2>  mov dword[PT_ADDR (0x1004)], 0
   231 0000030E 00                  <2>
   232 0000030F C70508108000233080- <2>  mov dword[PT_ADDR (0x1008)], PT_ADDR (0x3000) + PAGE_PDE_DIRECTORY_ATTR
   232 00000318 00                  <2>
   233 00000319 C7050C108000000000- <2>  mov dword[PT_ADDR (0x100C)], 0
   233 00000322 00                  <2>
   234 00000323 C70510108000234080- <2>  mov dword[PT_ADDR (0x1010)], PT_ADDR (0x4000) + PAGE_PDE_DIRECTORY_ATTR
   234 0000032C 00                  <2>
   235 0000032D C70514108000000000- <2>  mov dword[PT_ADDR (0x1014)], 0
   235 00000336 00                  <2>
   236 00000337 C70518108000235080- <2>  mov dword[PT_ADDR (0x1018)], PT_ADDR (0x5000) + PAGE_PDE_DIRECTORY_ATTR
   236 00000340 00                  <2>
   237 00000341 C7051C108000000000- <2>  mov dword[PT_ADDR (0x101C)], 0
   237 0000034A 00                  <2>
   238                              <2> 
   239                              <2> 
   240                              <2> 
   241                              <2> 
   242 0000034B B900080000          <2>  mov ecx, 0x800
   243                              <2> .pageTableEntriesLoop4Level:
   244 00000350 89C8                <2>  mov eax, ecx
   245 00000352 48                  <2>  dec eax
   246 00000353 C1E015              <2>  shl eax, 21
   247 00000356 05E3000000          <2>  add eax, PAGE_PDE_LARGEPAGE_ATTR
   248 0000035B 8904CDF81F8000      <2>  mov dword[ecx * 8 + PT_ADDR (0x2000 - 8)], eax
   249 00000362 C704CDFC1F80000000- <2>  mov dword[(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], %1
   249 0000036B 0000                <2>
   250 0000036D E2E1                <2>  loop .pageTableEntriesLoop4Level
   387 0000036F E942010000          <1>     jmp SetCr3
   388                              <1> 
   389                              <1> SevInit:
   390                              <1>     ;
   391                              <1>     ; SEV workflow
   392                              <1>     ;
   393                              <1>     ClearOvmfPageTables
   204 00000374 B900180000          <2>  mov ecx, 6 * 0x1000 / 4
   205 00000379 31C0                <2>  xor eax, eax
   206                              <2> .clearPageTablesMemoryLoop:
   207 0000037B 89048DFCFF7F00      <2>  mov dword[ecx * 4 + PT_ADDR (0) - 4], eax
   208 00000382 E2F7                <2>  loop .clearPageTablesMemoryLoop
   394                              <1>     ; If SEV is enabled, the C-bit position is always above 31.
   395                              <1>     ; The mask will be saved in the EDX and applied during the
   396                              <1>     ; the page table build below.
   397                              <1>     OneTimeCall   GetSevCBitMaskAbove31
    49 00000384 E916030000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   398                              <1>     CreatePageTables4Level edx
   217                              <2> 
   218                              <2> 
   219                              <2>  debugShowPostCode 0x41
   220                              <2> 
   221                              <2> 
   222                              <2> 
   223                              <2> 
   224 00000389 C70500008000231080- <2>  mov dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDE_DIRECTORY_ATTR
   224 00000392 00                  <2>
   225 00000393 C70504008000000000- <2>  mov dword[PT_ADDR (4)], 0
   225 0000039C 00                  <2>
   226                              <2> 
   227                              <2> 
   228                              <2> 
   229                              <2> 
   230 0000039D C70500108000232080- <2>  mov dword[PT_ADDR (0x1000)], PT_ADDR (0x2000) + PAGE_PDE_DIRECTORY_ATTR
   230 000003A6 00                  <2>
   231 000003A7 C70504108000000000- <2>  mov dword[PT_ADDR (0x1004)], 0
   231 000003B0 00                  <2>
   232 000003B1 C70508108000233080- <2>  mov dword[PT_ADDR (0x1008)], PT_ADDR (0x3000) + PAGE_PDE_DIRECTORY_ATTR
   232 000003BA 00                  <2>
   233 000003BB C7050C108000000000- <2>  mov dword[PT_ADDR (0x100C)], 0
   233 000003C4 00                  <2>
   234 000003C5 C70510108000234080- <2>  mov dword[PT_ADDR (0x1010)], PT_ADDR (0x4000) + PAGE_PDE_DIRECTORY_ATTR
   234 000003CE 00                  <2>
   235 000003CF C70514108000000000- <2>  mov dword[PT_ADDR (0x1014)], 0
   235 000003D8 00                  <2>
   236 000003D9 C70518108000235080- <2>  mov dword[PT_ADDR (0x1018)], PT_ADDR (0x5000) + PAGE_PDE_DIRECTORY_ATTR
   236 000003E2 00                  <2>
   237 000003E3 C7051C108000000000- <2>  mov dword[PT_ADDR (0x101C)], 0
   237 000003EC 00                  <2>
   238                              <2> 
   239                              <2> 
   240                              <2> 
   241                              <2> 
   242 000003ED B900080000          <2>  mov ecx, 0x800
   243                              <2> .pageTableEntriesLoop4Level:
   244 000003F2 89C8                <2>  mov eax, ecx
   245 000003F4 48                  <2>  dec eax
   246 000003F5 C1E015              <2>  shl eax, 21
   247 000003F8 05E3000000          <2>  add eax, PAGE_PDE_LARGEPAGE_ATTR
   248 000003FD 8904CDF81F8000      <2>  mov dword[ecx * 8 + PT_ADDR (0x2000 - 8)], eax
   249 00000404 8914CDFC1F8000      <2>  mov dword[(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], %1
   250 0000040B E2E5                <2>  loop .pageTableEntriesLoop4Level
   399                              <1>     ; Clear the C-bit from the GHCB page if the SEV-ES is enabled.
   400                              <1>     OneTimeCall   SevClearPageEncMaskForGhcbPage
    49 0000040D E92B020000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   401 00000412 E99F000000          <1>     jmp SetCr3
   402                              <1> 
   403                              <1> TdxBspInit:
   404                              <1>     ;
   405                              <1>     ; TDX BSP workflow
   406                              <1>     ;
   407                              <1>     ClearOvmfPageTables
   204 00000417 B900180000          <2>  mov ecx, 6 * 0x1000 / 4
   205 0000041C 31C0                <2>  xor eax, eax
   206                              <2> .clearPageTablesMemoryLoop:
   207 0000041E 89048DFCFF7F00      <2>  mov dword[ecx * 4 + PT_ADDR (0) - 4], eax
   208 00000425 E2F7                <2>  loop .clearPageTablesMemoryLoop
   408                              <1> %if PG_5_LEVEL
   409                              <1>     Check5LevelPaging Tdx4Level
   410                              <1>     CreatePageTables5Level 0
   411                              <1>     OneTimeCall TdxPostBuildPageTables5Level
   412                              <1>     Enable5LevelPaging
   413                              <1>     jmp SetCr3
   414                              <1> Tdx4Level:
   415                              <1> %endif
   416                              <1>     CreatePageTables4Level 0
   217                              <2> 
   218                              <2> 
   219                              <2>  debugShowPostCode 0x41
   220                              <2> 
   221                              <2> 
   222                              <2> 
   223                              <2> 
   224 00000427 C70500008000231080- <2>  mov dword[PT_ADDR (0)], PT_ADDR (0x1000) + PAGE_PDE_DIRECTORY_ATTR
   224 00000430 00                  <2>
   225 00000431 C70504008000000000- <2>  mov dword[PT_ADDR (4)], 0
   225 0000043A 00                  <2>
   226                              <2> 
   227                              <2> 
   228                              <2> 
   229                              <2> 
   230 0000043B C70500108000232080- <2>  mov dword[PT_ADDR (0x1000)], PT_ADDR (0x2000) + PAGE_PDE_DIRECTORY_ATTR
   230 00000444 00                  <2>
   231 00000445 C70504108000000000- <2>  mov dword[PT_ADDR (0x1004)], 0
   231 0000044E 00                  <2>
   232 0000044F C70508108000233080- <2>  mov dword[PT_ADDR (0x1008)], PT_ADDR (0x3000) + PAGE_PDE_DIRECTORY_ATTR
   232 00000458 00                  <2>
   233 00000459 C7050C108000000000- <2>  mov dword[PT_ADDR (0x100C)], 0
   233 00000462 00                  <2>
   234 00000463 C70510108000234080- <2>  mov dword[PT_ADDR (0x1010)], PT_ADDR (0x4000) + PAGE_PDE_DIRECTORY_ATTR
   234 0000046C 00                  <2>
   235 0000046D C70514108000000000- <2>  mov dword[PT_ADDR (0x1014)], 0
   235 00000476 00                  <2>
   236 00000477 C70518108000235080- <2>  mov dword[PT_ADDR (0x1018)], PT_ADDR (0x5000) + PAGE_PDE_DIRECTORY_ATTR
   236 00000480 00                  <2>
   237 00000481 C7051C108000000000- <2>  mov dword[PT_ADDR (0x101C)], 0
   237 0000048A 00                  <2>
   238                              <2> 
   239                              <2> 
   240                              <2> 
   241                              <2> 
   242 0000048B B900080000          <2>  mov ecx, 0x800
   243                              <2> .pageTableEntriesLoop4Level:
   244 00000490 89C8                <2>  mov eax, ecx
   245 00000492 48                  <2>  dec eax
   246 00000493 C1E015              <2>  shl eax, 21
   247 00000496 05E3000000          <2>  add eax, PAGE_PDE_LARGEPAGE_ATTR
   248 0000049B 8904CDF81F8000      <2>  mov dword[ecx * 8 + PT_ADDR (0x2000 - 8)], eax
   249 000004A2 C704CDFC1F80000000- <2>  mov dword[(ecx * 8 + PT_ADDR (0x2000 - 8)) + 4], %1
   249 000004AB 0000                <2>
   250 000004AD E2E1                <2>  loop .pageTableEntriesLoop4Level
   417                              <1>     OneTimeCall TdxPostBuildPageTables
    49 000004AF E9E1000000          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   418 000004B4 EB00                <1>     jmp SetCr3
   419                              <1> 
   420                              <1> SetCr3:
   421                              <1>     ;
   422                              <1>     ; common workflow
   423                              <1>     ;
   424                              <1>     ; Set CR3 now that the paging structures are available
   425                              <1>     ;
   426 000004B6 B800008000          <1>     mov     eax, PT_ADDR (0)
   427 000004BB 0F22D8              <1>     mov     cr3, eax
   428                              <1> 
   429                              <1>     OneTimeCallRet SetCr3ForPageTables64
    54 000004BE E962FDFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   145                                    %include "Ia32/IntelTdx.asm"
   146                              <1> ;------------------------------------------------------------------------------
   147                              <1> ; @file
   148                              <1> ;   Intel TDX routines
   149                              <1> ;
   150                              <1> ; Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
   151                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   152                              <1> ;
   153                              <1> ;------------------------------------------------------------------------------
   154                              <1> 
   155                              <1> %define VM_GUEST_TDX     2
   156                              <1> 
   157                              <1> BITS 32
   158                              <1> 
   159                              <1> ;
   160                              <1> ; Check if it is Intel Tdx
   161                              <1> ;
   162                              <1> ; Modified: EAX, EBX, ECX, EDX
   163                              <1> ;
   164                              <1> ; If it is Intel Tdx, EAX is 1
   165                              <1> ; If it is not Intel Tdx, EAX is 0
   166                              <1> ;
   167                              <1> IsTdx:
   168                              <1>     ;
   169                              <1>     ; CPUID (0)
   170                              <1>     ;
   171 000004C3 B800000000          <1>     mov     eax, 0
   172 000004C8 0FA2                <1>     cpuid
   173 000004CA 81FB47656E75        <1>     cmp     ebx, 0x756e6547  ; "Genu"
   174 000004D0 7556                <1>     jne     IsNotTdx
   175 000004D2 81FA696E6549        <1>     cmp     edx, 0x49656e69  ; "ineI"
   176 000004D8 754E                <1>     jne     IsNotTdx
   177 000004DA 81F96E74656C        <1>     cmp     ecx, 0x6c65746e  ; "ntel"
   178 000004E0 7546                <1>     jne     IsNotTdx
   179                              <1> 
   180                              <1>     ;
   181                              <1>     ; CPUID (1)
   182                              <1>     ;
   183 000004E2 B801000000          <1>     mov     eax, 1
   184 000004E7 0FA2                <1>     cpuid
   185 000004E9 F7C100000080        <1>     test    ecx, 0x80000000
   186 000004EF 7437                <1>     jz      IsNotTdx
   187                              <1> 
   188                              <1>     ;
   189                              <1>     ; CPUID[0].EAX >= 0x21?
   190                              <1>     ;
   191 000004F1 B800000000          <1>     mov     eax, 0
   192 000004F6 0FA2                <1>     cpuid
   193 000004F8 83F821              <1>     cmp     eax, 0x21
   194 000004FB 7C2B                <1>     jl      IsNotTdx
   195                              <1> 
   196                              <1>     ;
   197                              <1>     ; CPUID (0x21,0)
   198                              <1>     ;
   199 000004FD B821000000          <1>     mov     eax, 0x21
   200 00000502 B900000000          <1>     mov     ecx, 0
   201 00000507 0FA2                <1>     cpuid
   202                              <1> 
   203 00000509 81FB496E7465        <1>     cmp     ebx, 0x65746E49   ; "Inte"
   204 0000050F 7517                <1>     jne     IsNotTdx
   205 00000511 81FA6C544458        <1>     cmp     edx, 0x5844546C   ; "lTDX"
   206 00000517 750F                <1>     jne     IsNotTdx
   207 00000519 81F920202020        <1>     cmp     ecx, 0x20202020   ; "    "
   208 0000051F 7507                <1>     jne     IsNotTdx
   209                              <1> 
   210 00000521 B801000000          <1>     mov     eax, 1
   211 00000526 EB02                <1>     jmp     ExitIsTdx
   212                              <1> 
   213                              <1> IsNotTdx:
   214 00000528 31C0                <1>     xor     eax, eax
   215                              <1> 
   216                              <1> ExitIsTdx:
   217                              <1> 
   218                              <1>   OneTimeCallRet IsTdx
    54 0000052A EB02                <2>  jmp %1 %+ OneTimerCallReturn
   219                              <1> 
   220                              <1> ;
   221                              <1> ; Initialize work area if it is Tdx guest. Detailed definition is in
   222                              <1> ; OvmfPkg/Include/WorkArea.h.
   223                              <1> ; BSP and APs all go here. Only BSP initialize this work area.
   224                              <1> ;
   225                              <1> ; Param[in] EBX[5:0]    CPU Supported GPAW (48 or 52)
   226                              <1> ; Param[in] ESI[31:0]   vCPU ID (BSP is 0, others are AP)
   227                              <1> ;
   228                              <1> ; Modified:  EBX
   229                              <1> ;
   230                              <1> InitTdxWorkarea:
   231                              <1> 
   232                              <1>     ;
   233                              <1>     ; First check if it is Tdx
   234                              <1>     ;
   235                              <1>     OneTimeCall IsTdx
    49 0000052C EB95                <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   236                              <1> 
   237 0000052E 85C0                <1>     test    eax, eax
   238 00000530 7420                <1>     jz      ExitInitTdxWorkarea
   239                              <1> 
   240 00000532 83FE00              <1>     cmp     esi, 0
   241 00000535 740B                <1>     je      TdxBspEntry
   242                              <1> 
   243                              <1>     ;
   244                              <1>     ; In Td guest, BSP/AP shares the same entry point
   245                              <1>     ; BSP builds up the page table, while APs shouldn't do the same task.
   246                              <1>     ; Instead, APs just leverage the page table which is built by BSP.
   247                              <1>     ; APs will wait until the page table is ready.
   248                              <1>     ;
   249                              <1> TdxApWait:
   250 00000537 803D04B0800000      <1>     cmp     byte[TDX_WORK_AREA_PGTBL_READY], 0
   251 0000053E 74F7                <1>     je      TdxApWait
   252 00000540 EB10                <1>     jmp     ExitInitTdxWorkarea
   253                              <1> 
   254                              <1> TdxBspEntry:
   255                              <1>     ;
   256                              <1>     ; Set Type of WORK_AREA_GUEST_TYPE so that the following code can use
   257                              <1>     ; these information.
   258                              <1>     ;
   259 00000542 C60500B0800002      <1>     mov     byte[WORK_AREA_GUEST_TYPE], VM_GUEST_TDX
   260                              <1> 
   261                              <1>     ;
   262                              <1>     ; EBX[5:0] CPU supported GPA width
   263                              <1>     ;
   264 00000549 83E33F              <1>     and     ebx, 0x3f
   265 0000054C 891D08B08000        <1>     mov     DWORD[TDX_WORK_AREA_GPAW], ebx
   266                              <1> 
   267                              <1> ExitInitTdxWorkarea:
   268                              <1>     OneTimeCallRet InitTdxWorkarea
    54 00000552 EB24                <2>  jmp %1 %+ OneTimerCallReturn
   269                              <1> 
   270                              <1> ;
   271                              <1> ; Load the GDT and set the CS/DS/ES/FS/GS/SS.
   272                              <1> ;
   273                              <1> ; Modified:  EAX, DS, ES, FS, GS, SS, CS
   274                              <1> ;
   275                              <1> ReloadFlat32:
   276                              <1> 
   277 00000554 FA                  <1>     cli
   278 00000555 B8C8FEFFFF          <1>     mov     eax, ADDR_OF(gdtr)
   279 0000055A 0F0110              <1>     lgdt    [eax]
   280                              <1> 
   281 0000055D EA54FAFFFF1000      <1>     jmp     LINEAR_CODE_SEL:dword ADDR_OF(jumpToFlat32BitAndLandHere)
   282                              <1> 
   283                              <1> jumpToFlat32BitAndLandHere:
   284                              <1> 
   285                              <1>     debugShowPostCode POSTCODE_32BIT_MODE
   286                              <1> 
   287 00000564 66B81800            <1>     mov     ax, LINEAR_SEL
   288 00000568 8ED8                <1>     mov     ds, ax
   289 0000056A 8EC0                <1>     mov     es, ax
   290 0000056C 8EE0                <1>     mov     fs, ax
   291 0000056E 8EE8                <1>     mov     gs, ax
   292 00000570 8ED0                <1>     mov     ss, ax
   293                              <1> 
   294                              <1>     OneTimeCallRet ReloadFlat32
    54 00000572 EB02                <2>  jmp %1 %+ OneTimerCallReturn
   295                              <1> 
   296                              <1> ;
   297                              <1> ; Tdx initialization after entering into ResetVector
   298                              <1> ;
   299                              <1> ; Modified:  EAX, EBX, ECX, EDX, EBP, EDI, ESP
   300                              <1> ;
   301                              <1> InitTdx:
   302                              <1>     ;
   303                              <1>     ; First load the GDT and jump to Flat32 mode
   304                              <1>     ;
   305                              <1>     OneTimeCall ReloadFlat32
    49 00000574 EBDE                <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   306                              <1> 
   307                              <1>     ;
   308                              <1>     ; Initialization of Tdx work area
   309                              <1>     ;
   310                              <1>     OneTimeCall  InitTdxWorkarea
    49 00000576 EBB4                <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   311                              <1> 
   312                              <1>     OneTimeCallRet InitTdx
    54 00000578 E9C0040000          <2>  jmp %1 %+ OneTimerCallReturn
   313                              <1> 
   314                              <1> ;
   315                              <1> ; Check TDX features, TDX or TDX-BSP or TDX-APs?
   316                              <1> ;
   317                              <1> ; By design TDX BSP is reponsible for initializing the PageTables.
   318                              <1> ; After PageTables are ready, byte[TDX_WORK_AREA_PGTBL_READY] is set to 1.
   319                              <1> ; APs will spin when byte[TDX_WORK_AREA_PGTBL_READY] is 0 until it is set to 1.
   320                              <1> ;
   321                              <1> ; When this routine is run on TDX BSP, byte[TDX_WORK_AREA_PGTBL_READY] should be 0.
   322                              <1> ; When this routine is run on TDX APs, byte[TDX_WORK_AREA_PGTBL_READY] should be 1.
   323                              <1> ;
   324                              <1> ;
   325                              <1> ; Modified:  EAX, EDX
   326                              <1> ;
   327                              <1> ; 0-NonTdx, 1-TdxBsp, 2-TdxAps, 3-TdxAps5Level
   328                              <1> ;
   329                              <1> CheckTdxFeaturesBeforeBuildPagetables:
   330 0000057D 31C0                <1>     xor     eax, eax
   331 0000057F 803D00B0800002      <1>     cmp     byte[WORK_AREA_GUEST_TYPE], VM_GUEST_TDX
   332 00000586 7508                <1>     jne     NotTdx
   333                              <1> 
   334 00000588 31D2                <1>     xor     edx, edx
   335 0000058A A004B08000          <1>     mov     al, byte[TDX_WORK_AREA_PGTBL_READY]
   336 0000058F 40                  <1>     inc     eax
   337                              <1> 
   338                              <1> NotTdx:
   339                              <1>     OneTimeCallRet CheckTdxFeaturesBeforeBuildPagetables
    54 00000590 E91EFDFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   340                              <1> 
   341                              <1> ;
   342                              <1> ; Set byte[TDX_WORK_AREA_PGTBL_READY] to 1
   343                              <1> ;
   344                              <1> TdxPostBuildPageTables:
   345 00000595 C60504B0800001      <1>     mov     byte[TDX_WORK_AREA_PGTBL_READY], 1
   346                              <1>     OneTimeCallRet TdxPostBuildPageTables
    54 0000059C E913FFFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   347                              <1> 
   348                              <1> %if PG_5_LEVEL
   349                              <1> 
   350                              <1> ;
   351                              <1> ; Set byte[TDX_WORK_AREA_PGTBL_READY] to 2
   352                              <1> ;
   353                              <1> TdxPostBuildPageTables5Level:
   354                              <1>     mov     byte[TDX_WORK_AREA_PGTBL_READY], 2
   355                              <1>     OneTimeCallRet TdxPostBuildPageTables5Level
   356                              <1> 
   357                              <1> %endif
   358                              <1> 
   359                              <1> ;
   360                              <1> ; Check if TDX is enabled
   361                              <1> ;
   362                              <1> ; Modified:  EAX
   363                              <1> ;
   364                              <1> ; If TDX is enabled then EAX will be 1
   365                              <1> ; If TDX is disabled then EAX will be 0.
   366                              <1> ;
   367                              <1> IsTdxEnabled:
   368 000005A1 31C0                <1>     xor     eax, eax
   369 000005A3 803D00B0800002      <1>     cmp     byte[WORK_AREA_GUEST_TYPE], VM_GUEST_TDX
   370 000005AA 7505                <1>     jne     TdxNotEnabled
   371 000005AC B801000000          <1>     mov     eax, 1
   372                              <1> 
   373                              <1> TdxNotEnabled:
   374                              <1>     OneTimeCallRet IsTdxEnabled
    54 000005B1 E980FCFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   146                                    %include "X64/OvmfSevMetadata.asm"
   147                              <1> ;-----------------------------------------------------------------------------
   148                              <1> ; @file
   149                              <1> ; OVMF metadata for the AMD SEV confidential computing guests
   150                              <1> ;
   151                              <1> ; Copyright (c) 2021 - 2024, AMD Inc. All rights reserved.<BR>
   152                              <1> ;
   153                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   154                              <1> ;-----------------------------------------------------------------------------
   155                              <1> 
   156                              <1> BITS  64
   157                              <1> 
   158                              <1> %define OVMF_SEV_METADATA_VERSION     1
   159                              <1> 
   160                              <1> ; The section must be accepted or validated by the VMM before the boot
   161                              <1> %define OVMF_SECTION_TYPE_SNP_SEC_MEM     0x1
   162                              <1> 
   163                              <1> ; AMD SEV-SNP specific sections
   164                              <1> %define OVMF_SECTION_TYPE_SNP_SECRETS     0x2
   165                              <1> 
   166                              <1> ;
   167                              <1> ; The section contains the hypervisor pre-populated CPUID values.
   168                              <1> ; In the case of SEV-SNP, the CPUID values are filtered and measured by
   169                              <1> ; the SEV-SNP firmware.
   170                              <1> ; The CPUID format is documented in SEV-SNP firmware spec 0.9 section 7.1
   171                              <1> ; (CPUID function structure).
   172                              <1> ;
   173                              <1> %define OVMF_SECTION_TYPE_CPUID           0x3
   174                              <1> 
   175                              <1> ; The SVSM Calling Area Address (CAA)
   176                              <1> %define OVMF_SECTION_TYPE_SVSM_CAA        0x4
   177                              <1> 
   178                              <1> ; Kernel hashes section for measured direct boot
   179                              <1> %define OVMF_SECTION_TYPE_KERNEL_HASHES   0x10
   180                              <1> 
   181 000005B6 90<rep Ah>          <1> ALIGN 16
   182                              <1> 
   183 000005C0 00<rep 8h>          <1> TIMES (15 - ((OvmfSevGuidedStructureEnd - OvmfSevGuidedStructureStart + 15) % 16)) DB 0
   184                              <1> 
   185                              <1> OvmfSevGuidedStructureStart:
   186                              <1> ;
   187                              <1> ; OvmfSev metadata descriptor
   188                              <1> ;
   189                              <1> OvmfSevMetadataGuid:
   190                              <1> 
   191                              <1> _DescriptorSev:
   192 000005C8 41534556            <1>   DB 'A','S','E','V'                                        ; Signature
   193 000005CC 58000000            <1>   DD OvmfSevGuidedStructureEnd - _DescriptorSev             ; Length
   194 000005D0 01000000            <1>   DD OVMF_SEV_METADATA_VERSION                              ; Version
   195 000005D4 06000000            <1>   DD (OvmfSevGuidedStructureEnd - _DescriptorSev - 16) / 12 ; Number of sections
   196                              <1> 
   197                              <1> ; Region need to be pre-validated by the hypervisor
   198                              <1> PreValidate1:
   199 000005D8 00008000            <1>   DD  SNP_SEC_MEM_BASE_DESC_1
   200 000005DC 00900000            <1>   DD  SNP_SEC_MEM_SIZE_DESC_1
   201 000005E0 01000000            <1>   DD  OVMF_SECTION_TYPE_SNP_SEC_MEM
   202                              <1> PreValidate2:
   203 000005E4 00A08000            <1>   DD  SNP_SEC_MEM_BASE_DESC_2
   204 000005E8 00300000            <1>   DD  SNP_SEC_MEM_SIZE_DESC_2
   205 000005EC 01000000            <1>   DD  OVMF_SECTION_TYPE_SNP_SEC_MEM
   206                              <1> 
   207                              <1> ; SEV-SNP Secrets page
   208                              <1> SevSnpSecrets:
   209 000005F0 00D08000            <1>   DD  SEV_SNP_SECRETS_BASE
   210 000005F4 00100000            <1>   DD  SEV_SNP_SECRETS_SIZE
   211 000005F8 02000000            <1>   DD  OVMF_SECTION_TYPE_SNP_SECRETS
   212                              <1> 
   213                              <1> ; CPUID values
   214                              <1> CpuidSec:
   215 000005FC 00E08000            <1>   DD  CPUID_BASE
   216 00000600 00100000            <1>   DD  CPUID_SIZE
   217 00000604 03000000            <1>   DD  OVMF_SECTION_TYPE_CPUID
   218                              <1> 
   219                              <1> ; SVSM CAA page
   220                              <1> SvsmCaa:
   221 00000608 00F08000            <1>   DD  SVSM_CAA_BASE
   222 0000060C 00100000            <1>   DD  SVSM_CAA_SIZE
   223 00000610 04000000            <1>   DD  OVMF_SECTION_TYPE_SVSM_CAA
   224                              <1> 
   225                              <1> ; Region need to be pre-validated by the hypervisor
   226                              <1> PreValidate3:
   227 00000614 00008100            <1>   DD  SNP_SEC_MEM_BASE_DESC_3
   228 00000618 00000100            <1>   DD  SNP_SEC_MEM_SIZE_DESC_3
   229 0000061C 01000000            <1>   DD  OVMF_SECTION_TYPE_SNP_SEC_MEM
   230                              <1> 
   231                              <1> %if (SEV_SNP_KERNEL_HASHES_BASE > 0)
   232                              <1> ; Kernel hashes for measured direct boot, or zero page if
   233                              <1> ; there are no kernel hashes / SEV secrets
   234                              <1> SevSnpKernelHashes:
   235                              <1>   DD  SEV_SNP_KERNEL_HASHES_BASE
   236                              <1>   DD  SEV_SNP_KERNEL_HASHES_SIZE
   237                              <1>   DD  OVMF_SECTION_TYPE_KERNEL_HASHES
   238                              <1> %endif
   239                              <1> 
   240                              <1> OvmfSevGuidedStructureEnd:
   241                              <1>   ALIGN   16
   147                                  %endif
   148                                  
   149                                  %include "Ia32/AmdSev.asm"
   150                              <1> ;------------------------------------------------------------------------------
   151                              <1> ; @file
   152                              <1> ; Provide the functions to check whether SEV and SEV-ES is enabled.
   153                              <1> ;
   154                              <1> ; Copyright (c) 2017 - 2021, Advanced Micro Devices, Inc. All rights reserved.<BR>
   155                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   156                              <1> ;
   157                              <1> ;------------------------------------------------------------------------------
   158                              <1> 
   159                              <1> BITS    32
   160                              <1> 
   161                              <1> ;
   162                              <1> ; SEV-ES #VC exception handler support
   163                              <1> ;
   164                              <1> ; #VC handler local variable locations
   165                              <1> ;
   166                              <1> %define VC_CPUID_RESULT_EAX         0
   167                              <1> %define VC_CPUID_RESULT_EBX         4
   168                              <1> %define VC_CPUID_RESULT_ECX         8
   169                              <1> %define VC_CPUID_RESULT_EDX        12
   170                              <1> %define VC_GHCB_MSR_EDX            16
   171                              <1> %define VC_GHCB_MSR_EAX            20
   172                              <1> %define VC_CPUID_REQUEST_REGISTER  24
   173                              <1> %define VC_CPUID_FUNCTION          28
   174                              <1> 
   175                              <1> ; #VC handler total local variable size
   176                              <1> ;
   177                              <1> %define VC_VARIABLE_SIZE           32
   178                              <1> 
   179                              <1> ; #VC handler GHCB CPUID request/response protocol values
   180                              <1> ;
   181                              <1> %define GHCB_CPUID_REQUEST          4
   182                              <1> %define GHCB_CPUID_RESPONSE         5
   183                              <1> %define GHCB_CPUID_REGISTER_SHIFT  30
   184                              <1> %define CPUID_INSN_LEN              2
   185                              <1> 
   186                              <1> ; #VC handler offsets/sizes for accessing SNP CPUID page
   187                              <1> ;
   188                              <1> %define SNP_CPUID_ENTRY_SZ         48
   189                              <1> %define SNP_CPUID_COUNT             0
   190                              <1> %define SNP_CPUID_ENTRY            16
   191                              <1> %define SNP_CPUID_ENTRY_EAX_IN      0
   192                              <1> %define SNP_CPUID_ENTRY_ECX_IN      4
   193                              <1> %define SNP_CPUID_ENTRY_EAX        24
   194                              <1> %define SNP_CPUID_ENTRY_EBX        28
   195                              <1> %define SNP_CPUID_ENTRY_ECX        32
   196                              <1> %define SNP_CPUID_ENTRY_EDX        36
   197                              <1> 
   198                              <1> 
   199                              <1> %define SEV_GHCB_MSR                0xc0010130
   200                              <1> %define SEV_STATUS_MSR              0xc0010131
   201                              <1> 
   202                              <1> ; The #VC was not for CPUID
   203                              <1> %define TERM_VC_NOT_CPUID           1
   204                              <1> 
   205                              <1> ; The unexpected response code
   206                              <1> %define TERM_UNEXPECTED_RESP_CODE   2
   207                              <1> 
   208                              <1> %define PAGE_PRESENT            0x01
   209                              <1> %define PAGE_READ_WRITE         0x02
   210                              <1> %define PAGE_USER_SUPERVISOR    0x04
   211                              <1> %define PAGE_WRITE_THROUGH      0x08
   212                              <1> %define PAGE_CACHE_DISABLE     0x010
   213                              <1> %define PAGE_ACCESSED          0x020
   214                              <1> %define PAGE_DIRTY             0x040
   215                              <1> %define PAGE_PAT               0x080
   216                              <1> %define PAGE_GLOBAL           0x0100
   217                              <1> %define PAGE_2M_MBO            0x080
   218                              <1> %define PAGE_2M_PAT          0x01000
   219                              <1> 
   220                              <1> %define PAGE_4K_PDE_ATTR (PAGE_ACCESSED +                           PAGE_DIRTY +                           PAGE_READ_WRITE +                           PAGE_PRESENT)
   224                              <1> 
   225                              <1> %define PAGE_PDP_ATTR (PAGE_ACCESSED +                        PAGE_READ_WRITE +                        PAGE_PRESENT)
   228                              <1> 
   229                              <1> 
   230                              <1> ; Macro is used to issue the MSR protocol based VMGEXIT. The caller is
   231                              <1> ; responsible to populate values in the EDX:EAX registers. After the vmmcall
   232                              <1> ; returns, it verifies that the response code matches with the expected
   233                              <1> ; code. If it does not match then terminate the guest. The result of request
   234                              <1> ; is returned in the EDX:EAX.
   235                              <1> ;
   236                              <1> ; args 1:Request code, 2: Response code
   237                              <1> %macro VmgExit 2
   238                              <1>     ;
   239                              <1>     ; Add request code:
   240                              <1>     ;   GHCB_MSR[11:0]  = Request code
   241                              <1>     or      eax, %1
   242                              <1> 
   243                              <1>     mov     ecx, SEV_GHCB_MSR
   244                              <1>     wrmsr
   245                              <1> 
   246                              <1>     ; Issue VMGEXIT - NASM doesn't support the vmmcall instruction in 32-bit
   247                              <1>     ; mode, so work around this by temporarily switching to 64-bit mode.
   248                              <1>     ;
   249                              <1> BITS    64
   250                              <1>     rep     vmmcall
   251                              <1> BITS    32
   252                              <1> 
   253                              <1>     mov     ecx, SEV_GHCB_MSR
   254                              <1>     rdmsr
   255                              <1> 
   256                              <1>     ;
   257                              <1>     ; Verify the reponse code, if it does not match then request to terminate
   258                              <1>     ;   GHCB_MSR[11:0]  = Response code
   259                              <1>     mov     ecx, eax
   260                              <1>     and     ecx, 0xfff
   261                              <1>     cmp     ecx, %2
   262                              <1>     jne     SevEsUnexpectedRespTerminate
   263                              <1> %endmacro
   264                              <1> 
   265                              <1> ; Macro to terminate the guest using the VMGEXIT.
   266                              <1> ; arg 1: reason code
   267                              <1> %macro TerminateVmgExit 1
   268                              <1>     mov     eax, %1
   269                              <1>     ;
   270                              <1>     ; Use VMGEXIT to request termination. At this point the reason code is
   271                              <1>     ; located in EAX, so shift it left 16 bits to the proper location.
   272                              <1>     ;
   273                              <1>     ; EAX[11:0]  => 0x100 - request termination
   274                              <1>     ; EAX[15:12] => 0x1   - OVMF
   275                              <1>     ; EAX[23:16] => 0xXX  - REASON CODE
   276                              <1>     ;
   277                              <1>     shl     eax, 16
   278                              <1>     or      eax, 0x1100
   279                              <1>     xor     edx, edx
   280                              <1>     mov     ecx, SEV_GHCB_MSR
   281                              <1>     wrmsr
   282                              <1>     ;
   283                              <1>     ; Issue VMGEXIT - NASM doesn't support the vmmcall instruction in 32-bit
   284                              <1>     ; mode, so work around this by temporarily switching to 64-bit mode.
   285                              <1>     ;
   286                              <1> BITS    64
   287                              <1>     rep     vmmcall
   288                              <1> BITS    32
   289                              <1> 
   290                              <1>     ;
   291                              <1>     ; We shouldn't come back from the VMGEXIT, but if we do, just loop.
   292                              <1>     ;
   293                              <1> %%TerminateHlt:
   294                              <1>     hlt
   295                              <1>     jmp     %%TerminateHlt
   296                              <1> %endmacro
   297                              <1> 
   298                              <1> ; Terminate the guest due to unexpected response code.
   299                              <1> SevEsUnexpectedRespTerminate:
   300                              <1>     TerminateVmgExit    TERM_UNEXPECTED_RESP_CODE
   268 00000620 B802000000          <2>  mov eax, %1
   269                              <2> 
   270                              <2> 
   271                              <2> 
   272                              <2> 
   273                              <2> 
   274                              <2> 
   275                              <2> 
   276                              <2> 
   277 00000625 C1E010              <2>  shl eax, 16
   278 00000628 0D00110000          <2>  or eax, 0x1100
   279 0000062D 31D2                <2>  xor edx, edx
   280 0000062F B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   281 00000634 0F30                <2>  wrmsr
   282                              <2> 
   283                              <2> 
   284                              <2> 
   285                              <2> 
   286                              <2> BITS 64
   287 00000636 F30F01D9            <2>  rep vmmcall
   288                              <2> BITS 32
   289                              <2> 
   290                              <2> 
   291                              <2> 
   292                              <2> 
   293                              <2> %%TerminateHlt:
   294 0000063A F4                  <2>  hlt
   295 0000063B EBFD                <2>  jmp %%TerminateHlt
   301                              <1> 
   302                              <1> %ifdef ARCH_X64
   303                              <1> 
   304                              <1> ; If SEV-ES is enabled then initialize and make the GHCB page shared
   305                              <1> SevClearPageEncMaskForGhcbPage:
   306                              <1>     ; Check if SEV-ES is enabled
   307 0000063D B901000000          <1>     mov       ecx, 1
   308 00000642 0FA30D04B08000      <1>     bt        [SEV_ES_WORK_AREA_STATUS_MSR], ecx
   309 00000649 734F                <1>     jnc       SevClearPageEncMaskForGhcbPageExit
   310                              <1> 
   311                              <1>     ;
   312                              <1>     ; The initial GHCB will live at GHCB_BASE and needs to be un-encrypted.
   313                              <1>     ; This requires the 2MB page for this range be broken down into 512 4KB
   314                              <1>     ; pages.  All will be marked encrypted, except for the GHCB. Since the
   315                              <1>     ; original PMD entry is no longer a leaf entry, remove the encryption
   316                              <1>     ; bit when pointing to the PTE page.
   317                              <1>     ;
   318 0000064B B904000000          <1>     mov     ecx, (GHCB_BASE >> 21)
   319 00000650 B823808000          <1>     mov     eax, GHCB_PT_ADDR + PAGE_PDP_ATTR
   320 00000655 8904CD00208000      <1>     mov     [ecx * 8 + PT_ADDR (0x2000)], eax
   321 0000065C C704CD042080000000- <1>     mov     [ecx * 8 + PT_ADDR (0x2000) + 4], strict dword 0
   321 00000665 0000                <1>
   322                              <1> 
   323                              <1>     ;
   324                              <1>     ; Page Table Entries (512 * 4KB entries => 2MB)
   325                              <1>     ;
   326 00000667 B900020000          <1>     mov     ecx, 512
   327                              <1> pageTableEntries4kLoop:
   328 0000066C 89C8                <1>     mov     eax, ecx
   329 0000066E 48                  <1>     dec     eax
   330 0000066F C1E00C              <1>     shl     eax, 12
   331 00000672 0500008000          <1>     add     eax, GHCB_BASE & 0xFFE0_0000
   332 00000677 83C063              <1>     add     eax, PAGE_4K_PDE_ATTR
   333 0000067A 8904CDF87F8000      <1>     mov     [ecx * 8 + GHCB_PT_ADDR - 8], eax
   334 00000681 8914CDFC7F8000      <1>     mov     [(ecx * 8 + GHCB_PT_ADDR - 8) + 4], edx
   335 00000688 E2E2                <1>     loop    pageTableEntries4kLoop
   336                              <1> 
   337                              <1>     ;
   338                              <1>     ; Clear the encryption bit from the GHCB entry
   339                              <1>     ;
   340 0000068A B909000000          <1>     mov     ecx, (GHCB_BASE & 0x1F_FFFF) >> 12
   341 0000068F C704CD048080000000- <1>     mov     [ecx * 8 + GHCB_PT_ADDR + 4], strict dword 0
   341 00000698 0000                <1>
   342                              <1> 
   343                              <1> SevClearPageEncMaskForGhcbPageExit:
   344                              <1>     OneTimeCallRet SevClearPageEncMaskForGhcbPage
    54 0000069A E973FDFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   345                              <1> 
   346                              <1> ; Get the C-bit mask above 31.
   347                              <1> ; Modified: EDX
   348                              <1> ;
   349                              <1> ; The value is returned in the EDX
   350                              <1> GetSevCBitMaskAbove31:
   351 0000069F 8B1518B08000        <1>     mov       edx, dword[SEV_ES_WORK_AREA_ENC_MASK + 4]
   352                              <1>     OneTimeCallRet GetSevCBitMaskAbove31
    54 000006A5 E9DFFCFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   353                              <1> 
   354                              <1> %endif
   355                              <1> 
   356                              <1> ; Check if Secure Encrypted Virtualization (SEV) features are enabled.
   357                              <1> ;
   358                              <1> ; Register usage is tight in this routine, so multiple calls for the
   359                              <1> ; same CPUID and MSR data are performed to keep things simple.
   360                              <1> ;
   361                              <1> ; Modified:  EAX, EBX, ECX, EDX, ESP
   362                              <1> ;
   363                              <1> ; If SEV is enabled then EAX will be at least 32.
   364                              <1> ; If SEV is disabled then EAX will be zero.
   365                              <1> ;
   366                              <1> CheckSevFeatures:
   367                              <1>     ;
   368                              <1>     ; Clear the workarea, if SEV is enabled then later part of routine
   369                              <1>     ; will populate the workarea fields.
   370                              <1>     ;
   371 000006AA B919000000          <1>     mov    ecx, SEV_ES_WORK_AREA_SIZE
   372 000006AF B804B08000          <1>     mov    eax, SEV_ES_WORK_AREA
   373                              <1> ClearSevEsWorkArea:
   374 000006B4 C60000              <1>     mov    byte [eax], 0
   375 000006B7 40                  <1>     inc    eax
   376 000006B8 E2FA                <1>     loop   ClearSevEsWorkArea
   377                              <1> 
   378                              <1>     ;
   379                              <1>     ; Set up exception handlers to check for SEV-ES
   380                              <1>     ;   Load temporary RAM stack based on PCDs (see SevEsIdtVmmComm for
   381                              <1>     ;   stack usage)
   382                              <1>     ;   Establish exception handlers
   383                              <1>     ;
   384 000006BA BC00008200          <1>     mov       esp, SEV_ES_VC_TOP_OF_STACK
   385 000006BF B876FDFFFF          <1>     mov       eax, ADDR_OF(Idtr)
   386 000006C4 2E0F0118            <1>     lidt      [cs:eax]
   387                              <1> 
   388                              <1>     ; Check if we have a valid (0x8000_001F) CPUID leaf
   389                              <1>     ;   CPUID raises a #VC exception if running as an SEV-ES guest
   390 000006C8 B800000080          <1>     mov       eax, 0x80000000
   391 000006CD 0FA2                <1>     cpuid
   392                              <1> 
   393                              <1>     ; This check should fail on Intel or Non SEV AMD CPUs. In future if
   394                              <1>     ; Intel CPUs supports this CPUID leaf then we are guranteed to have exact
   395                              <1>     ; same bit definition.
   396 000006CF 3D1F000080          <1>     cmp       eax, 0x8000001f
   397 000006D4 7C5E                <1>     jl        NoSev
   398                              <1> 
   399                              <1>     ; Check for SEV memory encryption feature:
   400                              <1>     ; CPUID  Fn8000_001F[EAX] - Bit 1
   401                              <1>     ;   CPUID raises a #VC exception if running as an SEV-ES guest
   402 000006D6 B81F000080          <1>     mov       eax, 0x8000001f
   403 000006DB 0FA2                <1>     cpuid
   404 000006DD 0FBAE001            <1>     bt        eax, 1
   405 000006E1 7351                <1>     jnc       NoSev
   406                              <1> 
   407                              <1>     ; Check if SEV memory encryption is enabled
   408                              <1>     ;  MSR_0xC0010131 - Bit 0 (SEV enabled)
   409 000006E3 B9310101C0          <1>     mov       ecx, SEV_STATUS_MSR
   410 000006E8 0F32                <1>     rdmsr
   411 000006EA 0FBAE000            <1>     bt        eax, 0
   412 000006EE 7344                <1>     jnc       NoSev
   413                              <1> 
   414                              <1>     ; Set the work area header to indicate that the SEV is enabled
   415 000006F0 C60500B0800001      <1>     mov     byte[WORK_AREA_GUEST_TYPE], 1
   416                              <1> 
   417                              <1>     ; Save the SevStatus MSR value in the workarea
   418 000006F7 A304B08000          <1>     mov     [SEV_ES_WORK_AREA_STATUS_MSR], eax
   419 000006FC 891508B08000        <1>     mov     [SEV_ES_WORK_AREA_STATUS_MSR + 4], edx
   420                              <1> 
   421                              <1>     ; Check if SEV-ES is enabled
   422                              <1>     ;  MSR_0xC0010131 - Bit 1 (SEV-ES enabled)
   423 00000702 B9310101C0          <1>     mov       ecx, SEV_STATUS_MSR
   424 00000707 0F32                <1>     rdmsr
   425 00000709 0FBAE001            <1>     bt        eax, 1
   426 0000070D 7300                <1>     jnc       GetSevEncBit
   427                              <1> 
   428                              <1> GetSevEncBit:
   429                              <1>     ; Get pte bit position to enable memory encryption
   430                              <1>     ; CPUID Fn8000_001F[EBX] - Bits 5:0
   431                              <1>     ;
   432 0000070F 83E33F              <1>     and       ebx, 0x3f
   433 00000712 89D8                <1>     mov       eax, ebx
   434                              <1> 
   435                              <1>     ; The encryption bit position is always above 31
   436 00000714 83EB20              <1>     sub       ebx, 32
   437 00000717 7904                <1>     jns       SevSaveMask
   438                              <1> 
   439                              <1>     ; Encryption bit was reported as 31 or below, enter a HLT loop
   440                              <1> SevEncBitLowHlt:
   441 00000719 FA                  <1>     cli
   442 0000071A F4                  <1>     hlt
   443 0000071B EBFC                <1>     jmp       SevEncBitLowHlt
   444                              <1> 
   445                              <1> SevSaveMask:
   446 0000071D 31D2                <1>     xor       edx, edx
   447 0000071F 0FABDA              <1>     bts       edx, ebx
   448                              <1> 
   449 00000722 C70514B08000000000- <1>     mov       dword[SEV_ES_WORK_AREA_ENC_MASK], 0
   449 0000072B 00                  <1>
   450 0000072C 891518B08000        <1>     mov       dword[SEV_ES_WORK_AREA_ENC_MASK + 4], edx
   451 00000732 EB0F                <1>     jmp       SevExit
   452                              <1> 
   453                              <1> NoSev:
   454                              <1>     ;
   455                              <1>     ; Perform an SEV-ES sanity check by seeing if a #VC exception occurred.
   456                              <1>     ;
   457                              <1>     ; If SEV-ES is enabled, the CPUID instruction will trigger a #VC exception
   458                              <1>     ; where the RECEIVED_VC offset in the workarea will be set to one.
   459                              <1>     ;
   460 00000734 803D1CB0800000      <1>     cmp       byte[SEV_ES_WORK_AREA_RECEIVED_VC], 0
   461 0000073B 7404                <1>     jz        NoSevPass
   462                              <1> 
   463                              <1>     ;
   464                              <1>     ; A #VC was received, yet CPUID indicates no SEV-ES support, something
   465                              <1>     ; isn't right.
   466                              <1>     ;
   467                              <1> NoSevEsVcHlt:
   468 0000073D FA                  <1>     cli
   469 0000073E F4                  <1>     hlt
   470 0000073F EBFC                <1>     jmp       NoSevEsVcHlt
   471                              <1> 
   472                              <1> NoSevPass:
   473 00000741 31C0                <1>     xor       eax, eax
   474                              <1> 
   475                              <1> SevExit:
   476                              <1>     ;
   477                              <1>     ; Clear exception handlers and stack
   478                              <1>     ;
   479 00000743 50                  <1>     push      eax
   480 00000744 B87CFDFFFF          <1>     mov       eax, ADDR_OF(IdtrClear)
   481 00000749 2E0F0118            <1>     lidt      [cs:eax]
   482 0000074D 58                  <1>     pop       eax
   483 0000074E BC00000000          <1>     mov       esp, 0
   484                              <1> 
   485                              <1>     OneTimeCallRet CheckSevFeatures
    54 00000753 E972FBFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   486                              <1> 
   487                              <1> ; Start of #VC exception handling routines
   488                              <1> ;
   489                              <1> 
   490                              <1> SevEsIdtNotCpuid:
   491                              <1>     TerminateVmgExit TERM_VC_NOT_CPUID
   268 00000758 B801000000          <2>  mov eax, %1
   269                              <2> 
   270                              <2> 
   271                              <2> 
   272                              <2> 
   273                              <2> 
   274                              <2> 
   275                              <2> 
   276                              <2> 
   277 0000075D C1E010              <2>  shl eax, 16
   278 00000760 0D00110000          <2>  or eax, 0x1100
   279 00000765 31D2                <2>  xor edx, edx
   280 00000767 B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   281 0000076C 0F30                <2>  wrmsr
   282                              <2> 
   283                              <2> 
   284                              <2> 
   285                              <2> 
   286                              <2> BITS 64
   287 0000076E F30F01D9            <2>  rep vmmcall
   288                              <2> BITS 32
   289                              <2> 
   290                              <2> 
   291                              <2> 
   292                              <2> 
   293                              <2> %%TerminateHlt:
   294 00000772 F4                  <2>  hlt
   295 00000773 EBFD                <2>  jmp %%TerminateHlt
   492 00000775 CF                  <1>     iret
   493                              <1> 
   494                              <1> ; Use the SNP CPUID page to handle the cpuid lookup
   495                              <1> ;
   496                              <1> ;  Modified: EAX, EBX, ECX, EDX
   497                              <1> ;
   498                              <1> ;  Relies on the stack setup/usage in #VC handler:
   499                              <1> ;
   500                              <1> ;    On entry,
   501                              <1> ;      [esp + VC_CPUID_FUNCTION] contains EAX input to cpuid instruction
   502                              <1> ;
   503                              <1> ;    On return, stores corresponding results of CPUID lookup in:
   504                              <1> ;      [esp + VC_CPUID_RESULT_EAX]
   505                              <1> ;      [esp + VC_CPUID_RESULT_EBX]
   506                              <1> ;      [esp + VC_CPUID_RESULT_ECX]
   507                              <1> ;      [esp + VC_CPUID_RESULT_EDX]
   508                              <1> ;
   509                              <1> SnpCpuidLookup:
   510 00000776 8B44241C            <1>     mov     eax, [esp + VC_CPUID_FUNCTION]
   511 0000077A 8B1D00E08000        <1>     mov     ebx, [CPUID_BASE + SNP_CPUID_COUNT]
   512 00000780 B910E08000          <1>     mov     ecx, CPUID_BASE + SNP_CPUID_ENTRY
   513                              <1>     ; Zero these out now so we can simply return if lookup fails
   514 00000785 C7042400000000      <1>     mov     dword[esp + VC_CPUID_RESULT_EAX], 0
   515 0000078C C744240400000000    <1>     mov     dword[esp + VC_CPUID_RESULT_EBX], 0
   516 00000794 C744240800000000    <1>     mov     dword[esp + VC_CPUID_RESULT_ECX], 0
   517 0000079C C744240C00000000    <1>     mov     dword[esp + VC_CPUID_RESULT_EDX], 0
   518                              <1> 
   519                              <1> SnpCpuidCheckEntry:
   520 000007A4 83FB00              <1>     cmp     ebx, 0
   521 000007A7 0F84C0000000        <1>     je      VmmDoneSnpCpuid
   522 000007AD 3901                <1>     cmp     dword[ecx + SNP_CPUID_ENTRY_EAX_IN], eax
   523 000007AF 7506                <1>     jne     SnpCpuidCheckEntryNext
   524                              <1>     ; As with SEV-ES handler we assume requested CPUID sub-leaf/index is 0
   525 000007B1 83790400            <1>     cmp     dword[ecx + SNP_CPUID_ENTRY_ECX_IN], 0
   526 000007B5 7406                <1>     je      SnpCpuidEntryFound
   527                              <1> 
   528                              <1> SnpCpuidCheckEntryNext:
   529 000007B7 4B                  <1>     dec     ebx
   530 000007B8 83C130              <1>     add     ecx, SNP_CPUID_ENTRY_SZ
   531 000007BB EBE7                <1>     jmp     SnpCpuidCheckEntry
   532                              <1> 
   533                              <1> SnpCpuidEntryFound:
   534 000007BD 8B4118              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EAX]
   535 000007C0 890424              <1>     mov     [esp + VC_CPUID_RESULT_EAX], eax
   536 000007C3 8B411C              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EBX]
   537 000007C6 89442404            <1>     mov     [esp + VC_CPUID_RESULT_EBX], eax
   538 000007CA 8B4120              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_ECX]
   539 000007CD 89442408            <1>     mov     [esp + VC_CPUID_RESULT_ECX], eax
   540 000007D1 8B4124              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EDX]
   541 000007D4 8944240C            <1>     mov     [esp + VC_CPUID_RESULT_EDX], eax
   542 000007D8 E990000000          <1>     jmp     VmmDoneSnpCpuid
   543                              <1> 
   544                              <1> ;
   545                              <1> ; Total stack usage for the #VC handler is 44 bytes:
   546                              <1> ;   - 12 bytes for the exception IRET (after popping error code)
   547                              <1> ;   - 32 bytes for the local variables.
   548                              <1> ;
   549                              <1> SevEsIdtVmmComm:
   550                              <1>     ;
   551                              <1>     ; If we're here, then we are an SEV-ES guest and this
   552                              <1>     ; was triggered by a CPUID instruction
   553                              <1>     ;
   554                              <1>     ; Set the recievedVc field in the workarea to communicate that
   555                              <1>     ; a #VC was taken.
   556 000007DD C6051CB0800001      <1>     mov     byte[SEV_ES_WORK_AREA_RECEIVED_VC], 1
   557                              <1> 
   558 000007E4 59                  <1>     pop     ecx                     ; Error code
   559 000007E5 83F972              <1>     cmp     ecx, 0x72               ; Be sure it was CPUID
   560 000007E8 0F856AFFFFFF        <1>     jne     SevEsIdtNotCpuid
   561                              <1> 
   562                              <1>     ; Set up local variable room on the stack
   563                              <1>     ;   CPUID function         : + 28
   564                              <1>     ;   CPUID request register : + 24
   565                              <1>     ;   GHCB MSR (EAX)         : + 20
   566                              <1>     ;   GHCB MSR (EDX)         : + 16
   567                              <1>     ;   CPUID result (EDX)     : + 12
   568                              <1>     ;   CPUID result (ECX)     : + 8
   569                              <1>     ;   CPUID result (EBX)     : + 4
   570                              <1>     ;   CPUID result (EAX)     : + 0
   571 000007EE 83EC20              <1>     sub     esp, VC_VARIABLE_SIZE
   572                              <1> 
   573                              <1>     ; Save the CPUID function being requested
   574 000007F1 8944241C            <1>     mov     [esp + VC_CPUID_FUNCTION], eax
   575                              <1> 
   576                              <1>     ; If SEV-SNP is enabled, use the CPUID page to handle the CPUID
   577                              <1>     ; instruction.
   578 000007F5 B9310101C0          <1>     mov     ecx, SEV_STATUS_MSR
   579 000007FA 0F32                <1>     rdmsr
   580 000007FC 0FBAE002            <1>     bt      eax, 2
   581 00000800 0F8270FFFFFF        <1>     jc      SnpCpuidLookup
   582                              <1> 
   583                              <1>     ; The GHCB CPUID protocol uses the following mapping to request
   584                              <1>     ; a specific register:
   585                              <1>     ;   0 => EAX, 1 => EBX, 2 => ECX, 3 => EDX
   586                              <1>     ;
   587                              <1>     ; Set EAX as the first register to request. This will also be used as a
   588                              <1>     ; loop variable to request all register values (EAX to EDX).
   589 00000806 31C0                <1>     xor     eax, eax
   590 00000808 89442418            <1>     mov     [esp + VC_CPUID_REQUEST_REGISTER], eax
   591                              <1> 
   592                              <1>     ; Save current GHCB MSR value
   593 0000080C B9300101C0          <1>     mov     ecx, SEV_GHCB_MSR
   594 00000811 0F32                <1>     rdmsr
   595 00000813 89442414            <1>     mov     [esp + VC_GHCB_MSR_EAX], eax
   596 00000817 89542410            <1>     mov     [esp + VC_GHCB_MSR_EDX], edx
   597                              <1> 
   598                              <1> NextReg:
   599                              <1>     ;
   600                              <1>     ; Setup GHCB MSR
   601                              <1>     ;   GHCB_MSR[63:32] = CPUID function
   602                              <1>     ;   GHCB_MSR[31:30] = CPUID register
   603                              <1>     ;   GHCB_MSR[11:0]  = CPUID request protocol
   604                              <1>     ;
   605 0000081B 8B442418            <1>     mov     eax, [esp + VC_CPUID_REQUEST_REGISTER]
   606 0000081F 83F804              <1>     cmp     eax, 4
   607 00000822 7D3A                <1>     jge     VmmDone
   608                              <1> 
   609 00000824 C1E01E              <1>     shl     eax, GHCB_CPUID_REGISTER_SHIFT
   610 00000827 8B54241C            <1>     mov     edx, [esp + VC_CPUID_FUNCTION]
   611                              <1> 
   612                              <1>     VmgExit GHCB_CPUID_REQUEST, GHCB_CPUID_RESPONSE
   238                              <2> 
   239                              <2> 
   240                              <2> 
   241 0000082B 83C804              <2>  or eax, %1
   242                              <2> 
   243 0000082E B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   244 00000833 0F30                <2>  wrmsr
   245                              <2> 
   246                              <2> 
   247                              <2> 
   248                              <2> 
   249                              <2> BITS 64
   250 00000835 F30F01D9            <2>  rep vmmcall
   251                              <2> BITS 32
   252                              <2> 
   253 00000839 B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   254 0000083E 0F32                <2>  rdmsr
   255                              <2> 
   256                              <2> 
   257                              <2> 
   258                              <2> 
   259 00000840 89C1                <2>  mov ecx, eax
   260 00000842 81E1FF0F0000        <2>  and ecx, 0xfff
   261 00000848 83F905              <2>  cmp ecx, %2
   262 0000084B 0F85CFFDFFFF        <2>  jne SevEsUnexpectedRespTerminate
   613                              <1> 
   614                              <1>     ;
   615                              <1>     ; Response GHCB MSR
   616                              <1>     ;   GHCB_MSR[63:32] = CPUID register value
   617                              <1>     ;   GHCB_MSR[31:30] = CPUID register
   618                              <1>     ;   GHCB_MSR[11:0]  = CPUID response protocol
   619                              <1>     ;
   620                              <1> 
   621                              <1>     ; Save returned value
   622 00000851 C1E81E              <1>     shr     eax, GHCB_CPUID_REGISTER_SHIFT
   623 00000854 891484              <1>     mov     [esp + eax * 4], edx
   624                              <1> 
   625                              <1>     ; Next register
   626 00000857 66FF442418          <1>     inc     word [esp + VC_CPUID_REQUEST_REGISTER]
   627                              <1> 
   628 0000085C EBBD                <1>     jmp     NextReg
   629                              <1> 
   630                              <1> VmmDone:
   631                              <1>     ;
   632                              <1>     ; At this point we have all CPUID register values. Restore the GHCB MSR,
   633                              <1>     ; set the return register values and return.
   634                              <1>     ;
   635 0000085E 8B442414            <1>     mov     eax, [esp + VC_GHCB_MSR_EAX]
   636 00000862 8B542410            <1>     mov     edx, [esp + VC_GHCB_MSR_EDX]
   637 00000866 B9300101C0          <1>     mov     ecx, SEV_GHCB_MSR
   638 0000086B 0F30                <1>     wrmsr
   639                              <1> 
   640                              <1> VmmDoneSnpCpuid:
   641 0000086D 8B0424              <1>     mov     eax, [esp + VC_CPUID_RESULT_EAX]
   642 00000870 8B5C2404            <1>     mov     ebx, [esp + VC_CPUID_RESULT_EBX]
   643 00000874 8B4C2408            <1>     mov     ecx, [esp + VC_CPUID_RESULT_ECX]
   644 00000878 8B54240C            <1>     mov     edx, [esp + VC_CPUID_RESULT_EDX]
   645                              <1> 
   646 0000087C 83C420              <1>     add     esp, VC_VARIABLE_SIZE
   647                              <1> 
   648                              <1>     ; Update the EIP value to skip over the now handled CPUID instruction
   649                              <1>     ; (the CPUID instruction has a length of 2)
   650 0000087F 6683042402          <1>     add     word [esp], CPUID_INSN_LEN
   651 00000884 CF                  <1>     iret
   652                              <1> 
   653 00000885 90                  <1> ALIGN   2
   654                              <1> 
   655                              <1> Idtr:
   656 00000886 FF00                <1>     dw      IDT_END - IDT_BASE - 1  ; Limit
   657 00000888 90FDFFFF            <1>     dd      ADDR_OF(IDT_BASE)       ; Base
   658                              <1> 
   659                              <1> IdtrClear:
   660 0000088C 0000                <1>     dw      0                       ; Limit
   661 0000088E 00000000            <1>     dd      0                       ; Base
   662                              <1> 
   663 00000892 90<rep Eh>          <1> ALIGN   16
   664                              <1> 
   665                              <1> ;
   666                              <1> ; The Interrupt Descriptor Table (IDT)
   667                              <1> ;   This will be used to determine if SEV-ES is enabled.  Upon execution
   668                              <1> ;   of the CPUID instruction, a VMM Communication Exception will occur.
   669                              <1> ;   This will tell us if SEV-ES is enabled.  We can use the current value
   670                              <1> ;   of the GHCB MSR to determine the SEV attributes.
   671                              <1> ;
   672                              <1> IDT_BASE:
   673                              <1> ;
   674                              <1> ; Vectors 0 - 28 (No handlers)
   675                              <1> ;
   676                              <1> %rep 29
   677                              <1>     dw      0                                    ; Offset low bits 15..0
   678                              <1>     dw      0x10                                 ; Selector
   679                              <1>     db      0                                    ; Reserved
   680                              <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   681                              <1>     dw      0                                    ; Offset high bits 31..16
   682                              <1> %endrep
   677 000008A0 0000                <2>  dw 0
   678 000008A2 1000                <2>  dw 0x10
   679 000008A4 00                  <2>  db 0
   680 000008A5 8E                  <2>  db 0x8E
   681 000008A6 0000                <2>  dw 0
   677 000008A8 0000                <2>  dw 0
   678 000008AA 1000                <2>  dw 0x10
   679 000008AC 00                  <2>  db 0
   680 000008AD 8E                  <2>  db 0x8E
   681 000008AE 0000                <2>  dw 0
   677 000008B0 0000                <2>  dw 0
   678 000008B2 1000                <2>  dw 0x10
   679 000008B4 00                  <2>  db 0
   680 000008B5 8E                  <2>  db 0x8E
   681 000008B6 0000                <2>  dw 0
   677 000008B8 0000                <2>  dw 0
   678 000008BA 1000                <2>  dw 0x10
   679 000008BC 00                  <2>  db 0
   680 000008BD 8E                  <2>  db 0x8E
   681 000008BE 0000                <2>  dw 0
   677 000008C0 0000                <2>  dw 0
   678 000008C2 1000                <2>  dw 0x10
   679 000008C4 00                  <2>  db 0
   680 000008C5 8E                  <2>  db 0x8E
   681 000008C6 0000                <2>  dw 0
   677 000008C8 0000                <2>  dw 0
   678 000008CA 1000                <2>  dw 0x10
   679 000008CC 00                  <2>  db 0
   680 000008CD 8E                  <2>  db 0x8E
   681 000008CE 0000                <2>  dw 0
   677 000008D0 0000                <2>  dw 0
   678 000008D2 1000                <2>  dw 0x10
   679 000008D4 00                  <2>  db 0
   680 000008D5 8E                  <2>  db 0x8E
   681 000008D6 0000                <2>  dw 0
   677 000008D8 0000                <2>  dw 0
   678 000008DA 1000                <2>  dw 0x10
   679 000008DC 00                  <2>  db 0
   680 000008DD 8E                  <2>  db 0x8E
   681 000008DE 0000                <2>  dw 0
   677 000008E0 0000                <2>  dw 0
   678 000008E2 1000                <2>  dw 0x10
   679 000008E4 00                  <2>  db 0
   680 000008E5 8E                  <2>  db 0x8E
   681 000008E6 0000                <2>  dw 0
   677 000008E8 0000                <2>  dw 0
   678 000008EA 1000                <2>  dw 0x10
   679 000008EC 00                  <2>  db 0
   680 000008ED 8E                  <2>  db 0x8E
   681 000008EE 0000                <2>  dw 0
   677 000008F0 0000                <2>  dw 0
   678 000008F2 1000                <2>  dw 0x10
   679 000008F4 00                  <2>  db 0
   680 000008F5 8E                  <2>  db 0x8E
   681 000008F6 0000                <2>  dw 0
   677 000008F8 0000                <2>  dw 0
   678 000008FA 1000                <2>  dw 0x10
   679 000008FC 00                  <2>  db 0
   680 000008FD 8E                  <2>  db 0x8E
   681 000008FE 0000                <2>  dw 0
   677 00000900 0000                <2>  dw 0
   678 00000902 1000                <2>  dw 0x10
   679 00000904 00                  <2>  db 0
   680 00000905 8E                  <2>  db 0x8E
   681 00000906 0000                <2>  dw 0
   677 00000908 0000                <2>  dw 0
   678 0000090A 1000                <2>  dw 0x10
   679 0000090C 00                  <2>  db 0
   680 0000090D 8E                  <2>  db 0x8E
   681 0000090E 0000                <2>  dw 0
   677 00000910 0000                <2>  dw 0
   678 00000912 1000                <2>  dw 0x10
   679 00000914 00                  <2>  db 0
   680 00000915 8E                  <2>  db 0x8E
   681 00000916 0000                <2>  dw 0
   677 00000918 0000                <2>  dw 0
   678 0000091A 1000                <2>  dw 0x10
   679 0000091C 00                  <2>  db 0
   680 0000091D 8E                  <2>  db 0x8E
   681 0000091E 0000                <2>  dw 0
   677 00000920 0000                <2>  dw 0
   678 00000922 1000                <2>  dw 0x10
   679 00000924 00                  <2>  db 0
   680 00000925 8E                  <2>  db 0x8E
   681 00000926 0000                <2>  dw 0
   677 00000928 0000                <2>  dw 0
   678 0000092A 1000                <2>  dw 0x10
   679 0000092C 00                  <2>  db 0
   680 0000092D 8E                  <2>  db 0x8E
   681 0000092E 0000                <2>  dw 0
   677 00000930 0000                <2>  dw 0
   678 00000932 1000                <2>  dw 0x10
   679 00000934 00                  <2>  db 0
   680 00000935 8E                  <2>  db 0x8E
   681 00000936 0000                <2>  dw 0
   677 00000938 0000                <2>  dw 0
   678 0000093A 1000                <2>  dw 0x10
   679 0000093C 00                  <2>  db 0
   680 0000093D 8E                  <2>  db 0x8E
   681 0000093E 0000                <2>  dw 0
   677 00000940 0000                <2>  dw 0
   678 00000942 1000                <2>  dw 0x10
   679 00000944 00                  <2>  db 0
   680 00000945 8E                  <2>  db 0x8E
   681 00000946 0000                <2>  dw 0
   677 00000948 0000                <2>  dw 0
   678 0000094A 1000                <2>  dw 0x10
   679 0000094C 00                  <2>  db 0
   680 0000094D 8E                  <2>  db 0x8E
   681 0000094E 0000                <2>  dw 0
   677 00000950 0000                <2>  dw 0
   678 00000952 1000                <2>  dw 0x10
   679 00000954 00                  <2>  db 0
   680 00000955 8E                  <2>  db 0x8E
   681 00000956 0000                <2>  dw 0
   677 00000958 0000                <2>  dw 0
   678 0000095A 1000                <2>  dw 0x10
   679 0000095C 00                  <2>  db 0
   680 0000095D 8E                  <2>  db 0x8E
   681 0000095E 0000                <2>  dw 0
   677 00000960 0000                <2>  dw 0
   678 00000962 1000                <2>  dw 0x10
   679 00000964 00                  <2>  db 0
   680 00000965 8E                  <2>  db 0x8E
   681 00000966 0000                <2>  dw 0
   677 00000968 0000                <2>  dw 0
   678 0000096A 1000                <2>  dw 0x10
   679 0000096C 00                  <2>  db 0
   680 0000096D 8E                  <2>  db 0x8E
   681 0000096E 0000                <2>  dw 0
   677 00000970 0000                <2>  dw 0
   678 00000972 1000                <2>  dw 0x10
   679 00000974 00                  <2>  db 0
   680 00000975 8E                  <2>  db 0x8E
   681 00000976 0000                <2>  dw 0
   677 00000978 0000                <2>  dw 0
   678 0000097A 1000                <2>  dw 0x10
   679 0000097C 00                  <2>  db 0
   680 0000097D 8E                  <2>  db 0x8E
   681 0000097E 0000                <2>  dw 0
   677 00000980 0000                <2>  dw 0
   678 00000982 1000                <2>  dw 0x10
   679 00000984 00                  <2>  db 0
   680 00000985 8E                  <2>  db 0x8E
   681 00000986 0000                <2>  dw 0
   683                              <1> ;
   684                              <1> ; Vector 29 (VMM Communication Exception)
   685                              <1> ;
   686 00000988 CDFC                <1>     dw      (ADDR_OF(SevEsIdtVmmComm) & 0xffff)  ; Offset low bits 15..0
   687 0000098A 1000                <1>     dw      0x10                                 ; Selector
   688 0000098C 00                  <1>     db      0                                    ; Reserved
   689 0000098D 8E                  <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   690 0000098E FFFF                <1>     dw      (ADDR_OF(SevEsIdtVmmComm) >> 16)     ; Offset high bits 31..16
   691                              <1> ;
   692                              <1> ; Vectors 30 - 31 (No handlers)
   693                              <1> ;
   694                              <1> %rep 2
   695                              <1>     dw      0                                    ; Offset low bits 15..0
   696                              <1>     dw      0x10                                 ; Selector
   697                              <1>     db      0                                    ; Reserved
   698                              <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   699                              <1>     dw      0                                    ; Offset high bits 31..16
   700                              <1> %endrep
   695 00000990 0000                <2>  dw 0
   696 00000992 1000                <2>  dw 0x10
   697 00000994 00                  <2>  db 0
   698 00000995 8E                  <2>  db 0x8E
   699 00000996 0000                <2>  dw 0
   695 00000998 0000                <2>  dw 0
   696 0000099A 1000                <2>  dw 0x10
   697 0000099C 00                  <2>  db 0
   698 0000099D 8E                  <2>  db 0x8E
   699 0000099E 0000                <2>  dw 0
   701                              <1> IDT_END:
   150                                  
   151                                  %include "Ia16/Real16ToFlat32.asm"
   152                              <1> ;------------------------------------------------------------------------------
   153                              <1> ; @file
   154                              <1> ; Transition from 16 bit real mode into 32 bit flat protected mode
   155                              <1> ;
   156                              <1> ; Copyright (c) 2008 - 2022, Intel Corporation. All rights reserved.<BR>
   157                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   158                              <1> ;
   159                              <1> ;------------------------------------------------------------------------------
   160                              <1> 
   161                              <1> %define SEC_DEFAULT_CR0  0x00000023
   162                              <1> %define SEC_DEFAULT_CR4  0x640
   163                              <1> 
   164                              <1> BITS    16
   165                              <1> 
   166                              <1> ;
   167                              <1> ; Modified:  EAX, EBX
   168                              <1> ;
   169                              <1> ; @param[out]     DS       Selector allowing flat access to all addresses
   170                              <1> ; @param[out]     ES       Selector allowing flat access to all addresses
   171                              <1> ; @param[out]     FS       Selector allowing flat access to all addresses
   172                              <1> ; @param[out]     GS       Selector allowing flat access to all addresses
   173                              <1> ; @param[out]     SS       Selector allowing flat access to all addresses
   174                              <1> ;
   175                              <1> TransitionFromReal16To32BitFlat:
   176                              <1> 
   177                              <1>     debugShowPostCode POSTCODE_16BIT_MODE
   178                              <1> 
   179 000009A0 FA                  <1>     cli
   180                              <1> 
   181 000009A1 BB00F0              <1>     mov     bx, 0xf000
   182 000009A4 8EDB                <1>     mov     ds, bx
   183                              <1> 
   184 000009A6 BBC8FE              <1>     mov     bx, ADDR16_OF(gdtr)
   185                              <1> 
   186 000009A9 2E660F0117          <1> o32 lgdt    [cs:bx]
   187                              <1> 
   188 000009AE 66B823000000        <1>     mov     eax, SEC_DEFAULT_CR0
   189 000009B4 0F22C0              <1>     mov     cr0, eax
   190                              <1> 
   191 000009B7 66EAAFFEFFFF1000    <1>     jmp     LINEAR_CODE_SEL:dword ADDR_OF(jumpTo32BitAndLandHere)
   192                              <1> BITS    32
   193                              <1> jumpTo32BitAndLandHere:
   194                              <1> 
   195 000009BF B840060000          <1>     mov     eax, SEC_DEFAULT_CR4
   196 000009C4 0F22E0              <1>     mov     cr4, eax
   197                              <1> 
   198                              <1>     debugShowPostCode POSTCODE_32BIT_MODE
   199                              <1> 
   200 000009C7 66B81800            <1>     mov     ax, LINEAR_SEL
   201 000009CB 8ED8                <1>     mov     ds, ax
   202 000009CD 8EC0                <1>     mov     es, ax
   203 000009CF 8EE0                <1>     mov     fs, ax
   204 000009D1 8EE8                <1>     mov     gs, ax
   205 000009D3 8ED0                <1>     mov     ss, ax
   206                              <1> 
   207                              <1>     OneTimeCallRet TransitionFromReal16To32BitFlat
    54 000009D5 EB58                <2>  jmp %1 %+ OneTimerCallReturn
   208                              <1> 
   209 000009D7 90                  <1> ALIGN   2
   210                              <1> 
   211                              <1> gdtr:
   212 000009D8 3F00                <1>     dw      GDT_END - GDT_BASE - 1   ; GDT limit
   213 000009DA D0FEFFFF            <1>     dd      ADDR_OF(GDT_BASE)
   214                              <1> 
   215 000009DE 90<rep 2h>          <1> ALIGN   16
   216                              <1> 
   217                              <1> ;
   218                              <1> ; Macros for GDT entries
   219                              <1> ;
   220                              <1> 
   221                              <1> %define  PRESENT_FLAG(p) (p << 7)
   222                              <1> %define  DPL(dpl) (dpl << 5)
   223                              <1> %define  SYSTEM_FLAG(s) (s << 4)
   224                              <1> %define  DESC_TYPE(t) (t)
   225                              <1> 
   226                              <1> ; Type: data, expand-up, writable, accessed
   227                              <1> %define  DATA32_TYPE 3
   228                              <1> 
   229                              <1> ; Type: execute, readable, expand-up, accessed
   230                              <1> %define  CODE32_TYPE 0xb
   231                              <1> 
   232                              <1> ; Type: execute, readable, expand-up, accessed
   233                              <1> %define  CODE64_TYPE 0xb
   234                              <1> 
   235                              <1> %define  GRANULARITY_FLAG(g) (g << 7)
   236                              <1> %define  DEFAULT_SIZE32(d) (d << 6)
   237                              <1> %define  CODE64_FLAG(l) (l << 5)
   238                              <1> %define  UPPER_LIMIT(l) (l)
   239                              <1> 
   240                              <1> ;
   241                              <1> ; The Global Descriptor Table (GDT)
   242                              <1> ;
   243                              <1> 
   244                              <1> GDT_BASE:
   245                              <1> ; null descriptor
   246                              <1> NULL_SEL            equ $-GDT_BASE    ; Selector [0x0]
   247 000009E0 0000                <1>     DW      0            ; limit 15:0
   248 000009E2 0000                <1>     DW      0            ; base 15:0
   249 000009E4 00                  <1>     DB      0            ; base 23:16
   250 000009E5 00                  <1>     DB      0            ; sys flag, dpl, type
   251 000009E6 00                  <1>     DB      0            ; limit 19:16, flags
   252 000009E7 00                  <1>     DB      0            ; base 31:24
   253                              <1> 
   254                              <1> ; Spare segment descriptor
   255                              <1> SPARE1_SEL          equ $-GDT_BASE    ; Selector [0x8]
   256 000009E8 0000                <1>     DW      0            ; limit 15:0
   257 000009EA 0000                <1>     DW      0            ; base 15:0
   258 000009EC 00                  <1>     DB      0            ; base 23:16
   259 000009ED 00                  <1>     DB      0            ; sys flag, dpl, type
   260 000009EE 00                  <1>     DB      0            ; limit 19:16, flags
   261 000009EF 00                  <1>     DB      0            ; base 31:24
   262                              <1> 
   263                              <1> ; linear code segment descriptor
   264                              <1> LINEAR_CODE_SEL     equ $-GDT_BASE    ; Selector [0x10]
   265 000009F0 FFFF                <1>     DW      0xffff       ; limit 15:0
   266 000009F2 0000                <1>     DW      0            ; base 15:0
   267 000009F4 00                  <1>     DB      0            ; base 23:16
   268 000009F5 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE32_TYPE)           ; 09Bh
   269 000009F6 CF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(1)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 0CFh
   270 000009F7 00                  <1>     DB      0            ; base 31:24
   271                              <1> 
   272                              <1> ; linear data segment descriptor
   273                              <1> LINEAR_SEL          equ $-GDT_BASE    ; Selector [0x18]
   274 000009F8 FFFF                <1>     DW      0xffff       ; limit 15:0
   275 000009FA 0000                <1>     DW      0            ; base 15:0
   276 000009FC 00                  <1>     DB      0            ; base 23:16
   277 000009FD 93                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(DATA32_TYPE)           ; 093h
   278 000009FE CF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(1)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 0CFh
   279 000009FF 00                  <1>     DB      0            ; base 31:24
   280                              <1> 
   281                              <1> ; Spare segment descriptor
   282                              <1> SPARE2_SEL          equ $-GDT_BASE    ; Selector [0x20]
   283 00000A00 0000                <1>     DW      0            ; limit 15:0
   284 00000A02 0000                <1>     DW      0            ; base 15:0
   285 00000A04 00                  <1>     DB      0            ; base 23:16
   286 00000A05 00                  <1>     DB      0            ; sys flag, dpl, type
   287 00000A06 00                  <1>     DB      0            ; limit 19:16, flags
   288 00000A07 00                  <1>     DB      0            ; base 31:24
   289                              <1> 
   290                              <1> ; linear code (16-bit) segment descriptor
   291                              <1> LINEAR_CODE16_SEL   equ $-GDT_BASE    ; Selector [0x28]
   292 00000A08 FFFF                <1>     DW      0xffff       ; limit 15:0
   293 00000A0A 0000                <1>     DW      0            ; base 15:0
   294 00000A0C 00                  <1>     DB      0            ; base 23:16
   295 00000A0D 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE32_TYPE)           ; 09Bh
   296 00000A0E 8F                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(0)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 08Fh
   297 00000A0F 00                  <1>     DB      0            ; base 31:24
   298                              <1> 
   299                              <1> ; linear data (16-bit) segment descriptor
   300                              <1> LINEAR_DATA16_SEL   equ $-GDT_BASE    ; Selector [0x30]
   301 00000A10 FFFF                <1>     DW      0xffff       ; limit 15:0
   302 00000A12 0000                <1>     DW      0            ; base 15:0
   303 00000A14 00                  <1>     DB      0            ; base 23:16
   304 00000A15 93                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(DATA32_TYPE)           ; 093h
   305 00000A16 00                  <1>     DB      0
   306 00000A17 00                  <1>     DB      0            ; base 31:24
   307                              <1> 
   308                              <1> ; linear code (64-bit) segment descriptor
   309                              <1> LINEAR_CODE64_SEL   equ $-GDT_BASE    ; Selector [0x38]
   310 00000A18 FFFF                <1>     DW      0xffff       ; limit 15:0
   311 00000A1A 0000                <1>     DW      0            ; base 15:0
   312 00000A1C 00                  <1>     DB      0            ; base 23:16
   313 00000A1D 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE64_TYPE)           ; 09Bh
   314 00000A1E AF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(0)|CODE64_FLAG(1)|UPPER_LIMIT(0xf)  ; 0AFh
   315 00000A1F 00                  <1>     DB      0            ; base 31:24
   316                              <1> 
   317                              <1> GDT_END:
   318                              <1> 
   152                                  %include "Ia16/Init16.asm"
   153                              <1> ;------------------------------------------------------------------------------
   154                              <1> ; @file
   155                              <1> ; 16-bit initialization code
   156                              <1> ;
   157                              <1> ; Copyright (c) 2008 - 2009, Intel Corporation. All rights reserved.<BR>
   158                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   159                              <1> ;
   160                              <1> ;------------------------------------------------------------------------------
   161                              <1> 
   162                              <1> 
   163                              <1> BITS    16
   164                              <1> 
   165                              <1> ;
   166                              <1> ; @param[out] DI    'BP' to indicate boot-strap processor
   167                              <1> ;
   168                              <1> EarlyBspInitReal16:
   169 00000A20 BF4250              <1>     mov     di, 'BP'
   170 00000A23 EB05                <1>     jmp     short Main16
   171                              <1> 
   172                              <1> ;
   173                              <1> ; Modified:  EAX
   174                              <1> ;
   175                              <1> ; @param[in]  EAX   Initial value of the EAX register (BIST: Built-in Self Test)
   176                              <1> ; @param[out] ESP   Initial value of the EAX register (BIST: Built-in Self Test)
   177                              <1> ;
   178                              <1> EarlyInit16:
   179                              <1>     ;
   180                              <1>     ; ESP -  Initial value of the EAX register (BIST: Built-in Self Test)
   181                              <1>     ;
   182 00000A25 6689C4              <1>     mov     esp, eax
   183                              <1> 
   184                              <1>     debugInitialize
    61                              <2> 
    62                              <2> 
    63                              <2> 
   185                              <1> 
   186                              <1>     OneTimeCallRet EarlyInit16
    54 00000A28 EB02                <2>  jmp %1 %+ OneTimerCallReturn
   187                              <1> 
   153                                  
   154                                  %include "Main.asm"
   155                              <1> ;------------------------------------------------------------------------------
   156                              <1> ; @file
   157                              <1> ; Main routine of the pre-SEC code up through the jump into SEC
   158                              <1> ;
   159                              <1> ; Copyright (c) 2008 - 2009, Intel Corporation. All rights reserved.<BR>
   160                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   161                              <1> ;
   162                              <1> ;------------------------------------------------------------------------------
   163                              <1> 
   164                              <1> 
   165                              <1> BITS    16
   166                              <1> 
   167                              <1> ;
   168                              <1> ; Modified:  EBX, ECX, EDX, EBP
   169                              <1> ;
   170                              <1> ; @param[in,out]  RAX/EAX  Initial value of the EAX register
   171                              <1> ;                          (BIST: Built-in Self Test)
   172                              <1> ; @param[in,out]  DI       'BP': boot-strap processor, or
   173                              <1> ;                          'AP': application processor
   174                              <1> ; @param[out]     RBP/EBP  Address of Boot Firmware Volume (BFV)
   175                              <1> ; @param[out]     DS       Selector allowing flat access to all addresses
   176                              <1> ; @param[out]     ES       Selector allowing flat access to all addresses
   177                              <1> ; @param[out]     FS       Selector allowing flat access to all addresses
   178                              <1> ; @param[out]     GS       Selector allowing flat access to all addresses
   179                              <1> ; @param[out]     SS       Selector allowing flat access to all addresses
   180                              <1> ;
   181                              <1> ; @return         None  This routine jumps to SEC and does not return
   182                              <1> ;
   183                              <1> Main16:
   184                              <1>     OneTimeCall EarlyInit16
    49 00000A2A EBF9                <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   185                              <1> 
   186                              <1>     ;
   187                              <1>     ; Transition the processor from 16-bit real mode to 32-bit flat mode
   188                              <1>     ;
   189                              <1>     OneTimeCall TransitionFromReal16To32BitFlat
    49 00000A2C E971FF              <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   190                              <1> 
   191                              <1> BITS    32
   192                              <1> 
   193                              <1>     ; Clear the WorkArea header. The SEV probe routines will populate the
   194                              <1>     ; work area when detected.
   195 00000A2F C60500B0800000      <1>     mov     byte[WORK_AREA_GUEST_TYPE], 0
   196                              <1> 
   197                              <1> %ifdef ARCH_X64
   198                              <1> 
   199 00000A36 EB05                <1>     jmp SearchBfv
   200                              <1> 
   201                              <1> ;
   202                              <1> ; Entry point of Main32
   203                              <1> ;
   204                              <1> Main32:
   205                              <1>     OneTimeCall InitTdx
    49 00000A38 E937FBFFFF          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   206                              <1> 
   207                              <1> SearchBfv:
   208                              <1> 
   209                              <1> %endif
   210                              <1> 
   211                              <1>     ;
   212                              <1>     ; Search for the Boot Firmware Volume (BFV)
   213                              <1>     ;
   214                              <1>     OneTimeCall Flat32SearchForBfvBase
    49 00000A3D E9BEF5FFFF          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   215                              <1> 
   216                              <1>     ;
   217                              <1>     ; EBP - Start of BFV
   218                              <1>     ;
   219                              <1> 
   220                              <1>     ;
   221                              <1>     ; Search for the SEC entry point
   222                              <1>     ;
   223                              <1>     OneTimeCall Flat32SearchForSecEntryPoint
    49 00000A42 E930F6FFFF          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   224                              <1> 
   225                              <1>     ;
   226                              <1>     ; ESI - SEC Core entry point
   227                              <1>     ; EBP - Start of BFV
   228                              <1>     ;
   229                              <1> 
   230                              <1> %ifdef ARCH_IA32
   231                              <1> 
   232                              <1>     ;
   233                              <1>     ; SEV support can be built and run using the Ia32/X64 split environment.
   234                              <1>     ; Set the OVMF/SEV work area as appropriate.
   235                              <1>     ;
   236                              <1>     OneTimeCall CheckSevFeatures
   237                              <1> 
   238                              <1>     ;
   239                              <1>     ; Restore initial EAX value into the EAX register
   240                              <1>     ;
   241                              <1>     mov     eax, esp
   242                              <1> 
   243                              <1>     ;
   244                              <1>     ; Jump to the 32-bit SEC entry point
   245                              <1>     ;
   246                              <1>     jmp     esi
   247                              <1> 
   248                              <1> %else
   249                              <1> 
   250                              <1>     ;
   251                              <1>     ; Transition the processor from 32-bit flat mode to 64-bit flat mode
   252                              <1>     ;
   253                              <1>     OneTimeCall Transition32FlatTo64Flat
    49 00000A47 E9D4F7FFFF          <2>  jmp %1
    50                              <2> %1 %+ OneTimerCallReturn:
   254                              <1> 
   255                              <1> BITS    64
   256                              <1> 
   257                              <1>     ;
   258                              <1>     ; Some values were calculated in 32-bit mode.  Make sure the upper
   259                              <1>     ; 32-bits of 64-bit registers are zero for these values.
   260                              <1>     ;
   261 00000A4C B8FFFFFFFF          <1>     mov     rax, 0x00000000ffffffff
   262 00000A51 4821C6              <1>     and     rsi, rax
   263 00000A54 4821C5              <1>     and     rbp, rax
   264 00000A57 4821C4              <1>     and     rsp, rax
   265                              <1> 
   266                              <1>     ;
   267                              <1>     ; RSI - SEC Core entry point
   268                              <1>     ; RBP - Start of BFV
   269                              <1>     ;
   270                              <1> 
   271                              <1>     ;
   272                              <1>     ; Restore initial EAX value into the RAX register
   273                              <1>     ;
   274 00000A5A 4889E0              <1>     mov     rax, rsp
   275                              <1> 
   276                              <1>     ;
   277                              <1>     ; Jump to the 64-bit SEC entry point
   278                              <1>     ;
   279 00000A5D FFE6                <1>     jmp     rsi
   280                              <1> 
   281                              <1> %endif
   155                                  
   156                                    %define SEV_ES_AP_RESET_IP 8433668
   157                                    %define SEV_LAUNCH_SECRET_BASE 00h
   158                                    %define SEV_LAUNCH_SECRET_SIZE 00h
   159                                    %define SEV_FW_HASH_BLOCK_BASE 00h
   160                                    %define SEV_FW_HASH_BLOCK_SIZE 00h
   161                                  %include "Ia16/ResetVectorVtf0.asm"
   162                              <1> ;------------------------------------------------------------------------------
   163                              <1> ; @file
   164                              <1> ; First code executed by processor after resetting.
   165                              <1> ; Derived from UefiCpuPkg/ResetVector/Vtf0/Ia16/ResetVectorVtf0.asm
   166                              <1> ;
   167                              <1> ; Copyright (c) 2008 - 2014, Intel Corporation. All rights reserved.<BR>
   168                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
   169                              <1> ;
   170                              <1> ;------------------------------------------------------------------------------
   171                              <1> 
   172                              <1> BITS    16
   173                              <1> 
   174 00000A5F 90                  <1> ALIGN   16
   175                              <1> 
   176                              <1> ;
   177                              <1> ; Pad the image size to 4k when page tables are in VTF0
   178                              <1> ;
   179                              <1> ; If the VTF0 image has page tables built in, then we need to make
   180                              <1> ; sure the end of VTF0 is 4k above where the page tables end.
   181                              <1> ;
   182                              <1> ; This is required so the page tables will be 4k aligned when VTF0 is
   183                              <1> ; located just below 0x100000000 (4GB) in the firmware device.
   184                              <1> ;
   185                              <1> %ifdef ALIGN_TOP_TO_4K_FOR_PAGING
   186                              <1>     TIMES (0x1000 - ($ - EndOfPageTables) - 0x20) DB 0
   187                              <1> %endif
   188                              <1> 
   189                              <1> ;
   190                              <1> ; Padding to ensure first guid starts at 0xffffffd0
   191                              <1> ;
   192 00000A60 00<rep 8h>          <1> TIMES (15 - ((guidedStructureEnd - guidedStructureStart + 15) % 16)) DB 0
   193                              <1> 
   194                              <1> ; GUIDed structure.  To traverse this you should first verify the
   195                              <1> ; presence of the table footer guid
   196                              <1> ; (96b582de-1fb2-45f7-baea-a366c55a082d) at 0xffffffd0.  If that
   197                              <1> ; is found, the two bytes at 0xffffffce are the entire table length.
   198                              <1> ;
   199                              <1> ; The table is composed of structures with the form:
   200                              <1> ;
   201                              <1> ; Data (arbitrary bytes identified by guid)
   202                              <1> ; length from start of data to end of guid (2 bytes)
   203                              <1> ; guid (16 bytes)
   204                              <1> ;
   205                              <1> ; so work back from the footer using the length to traverse until you
   206                              <1> ; either find the guid you're looking for or run off the beginning of
   207                              <1> ; the table.
   208                              <1> ;
   209                              <1> guidedStructureStart:
   210                              <1> 
   211                              <1> %ifdef ARCH_X64
   212                              <1> ;
   213                              <1> ; TDX Metadata offset block
   214                              <1> ;
   215                              <1> ; TdxMetadata.asm is included in ARCH_X64 because Inte TDX is only
   216                              <1> ; available in ARCH_X64. Below block describes the offset of
   217                              <1> ; TdxMetadata block in Ovmf image
   218                              <1> ;
   219                              <1> ; GUID : e47a6535-984a-4798-865e-4685a7bf8ec2
   220                              <1> ;
   221                              <1> tdxMetadataOffsetStart:
   222 00000A68 C0090000            <1>     DD      fourGigabytes - TdxMetadataGuid - 16
   223 00000A6C 1600                <1>     DW      tdxMetadataOffsetEnd - tdxMetadataOffsetStart
   224 00000A6E 35657AE44A989847    <1>     DB      0x35, 0x65, 0x7a, 0xe4, 0x4a, 0x98, 0x98, 0x47
   225 00000A76 865E4685A7BF8EC2    <1>     DB      0x86, 0x5e, 0x46, 0x85, 0xa7, 0xbf, 0x8e, 0xc2
   226                              <1> tdxMetadataOffsetEnd:
   227                              <1> 
   228                              <1> ;
   229                              <1> ; SEV metadata descriptor
   230                              <1> ;
   231                              <1> ; Provide the start offset of the metadata blob within the OVMF binary.
   232                              <1> 
   233                              <1> ; GUID : dc886566-984a-4798-A75e-5585a7bf67cc
   234                              <1> ;
   235                              <1> OvmfSevMetadataOffsetStart:
   236 00000A7E 48050000            <1>   DD      (fourGigabytes - OvmfSevMetadataGuid)
   237 00000A82 1600                <1>   DW      OvmfSevMetadataOffsetEnd - OvmfSevMetadataOffsetStart
   238 00000A84 666588DC4A989847    <1>   DB      0x66, 0x65, 0x88, 0xdc, 0x4a, 0x98, 0x98, 0x47
   239 00000A8C A75E5585A7BF67CC    <1>   DB      0xA7, 0x5e, 0x55, 0x85, 0xa7, 0xbf, 0x67, 0xcc
   240                              <1> OvmfSevMetadataOffsetEnd:
   241                              <1> 
   242                              <1> %endif
   243                              <1> 
   244                              <1> ; SEV Hash Table Block
   245                              <1> ;
   246                              <1> ; This describes the guest ram area where the hypervisor should
   247                              <1> ; install a table describing the hashes of certain firmware configuration
   248                              <1> ; device files that would otherwise be passed in unchecked.  The current
   249                              <1> ; use is for the kernel, initrd and command line values, but others may be
   250                              <1> ; added.  The data format is:
   251                              <1> ;
   252                              <1> ; base physical address (32 bit word)
   253                              <1> ; table length (32 bit word)
   254                              <1> ;
   255                              <1> ; GUID (SEV FW config hash block): 7255371f-3a3b-4b04-927b-1da6efa8d454
   256                              <1> ;
   257                              <1> sevFwHashBlockStart:
   258 00000A94 00000000            <1>     DD      SEV_FW_HASH_BLOCK_BASE
   259 00000A98 00000000            <1>     DD      SEV_FW_HASH_BLOCK_SIZE
   260 00000A9C 1A00                <1>     DW      sevFwHashBlockEnd - sevFwHashBlockStart
   261 00000A9E 1F3755723B3A044B    <1>     DB      0x1f, 0x37, 0x55, 0x72, 0x3b, 0x3a, 0x04, 0x4b
   262 00000AA6 927B1DA6EFA8D454    <1>     DB      0x92, 0x7b, 0x1d, 0xa6, 0xef, 0xa8, 0xd4, 0x54
   263                              <1> sevFwHashBlockEnd:
   264                              <1> 
   265                              <1> ; SEV Secret block
   266                              <1> ;
   267                              <1> ; This describes the guest ram area where the hypervisor should
   268                              <1> ; inject the secret.  The data format is:
   269                              <1> ;
   270                              <1> ; base physical address (32 bit word)
   271                              <1> ; table length (32 bit word)
   272                              <1> ;
   273                              <1> ; GUID (SEV secret block): 4c2eb361-7d9b-4cc3-8081-127c90d3d294
   274                              <1> ;
   275                              <1> sevSecretBlockStart:
   276 00000AAE 00000000            <1>     DD      SEV_LAUNCH_SECRET_BASE
   277 00000AB2 00000000            <1>     DD      SEV_LAUNCH_SECRET_SIZE
   278 00000AB6 1A00                <1>     DW      sevSecretBlockEnd - sevSecretBlockStart
   279 00000AB8 61B32E4C9B7DC34C    <1>     DB      0x61, 0xB3, 0x2E, 0x4C, 0x9B, 0x7D, 0xC3, 0x4C
   280 00000AC0 8081127C90D3D294    <1>     DB      0x80, 0x81, 0x12, 0x7C, 0x90, 0xD3, 0xD2, 0x94
   281                              <1> sevSecretBlockEnd:
   282                              <1> 
   283                              <1> ;
   284                              <1> ; SEV-ES Processor Reset support
   285                              <1> ;
   286                              <1> ; sevEsResetBlock:
   287                              <1> ;   For the initial boot of an AP under SEV-ES, the "reset" RIP must be
   288                              <1> ;   programmed to the RAM area defined by SEV_ES_AP_RESET_IP. The data
   289                              <1> ;   format is:
   290                              <1> ;
   291                              <1> ;   IP value [0:15]
   292                              <1> ;   CS segment base [31:16]
   293                              <1> ;
   294                              <1> ;   GUID (SEV-ES reset block): 00f771de-1a7e-4fcb-890e-68c77e2fb44e
   295                              <1> ;
   296                              <1> ;   A hypervisor reads the CS segement base and IP value. The CS segment base
   297                              <1> ;   value represents the high order 16-bits of the CS segment base, so the
   298                              <1> ;   hypervisor must left shift the value of the CS segement base by 16 bits to
   299                              <1> ;   form the full CS segment base for the CS segment register. It would then
   300                              <1> ;   program the EIP register with the IP value as read.
   301                              <1> ;
   302                              <1> 
   303                              <1> sevEsResetBlockStart:
   304 00000AC8 04B08000            <1>     DD      SEV_ES_AP_RESET_IP
   305 00000ACC 1600                <1>     DW      sevEsResetBlockEnd - sevEsResetBlockStart
   306 00000ACE DE71F7007E1ACB4F    <1>     DB      0xDE, 0x71, 0xF7, 0x00, 0x7E, 0x1A, 0xCB, 0x4F
   307 00000AD6 890E68C77E2FB44E    <1>     DB      0x89, 0x0E, 0x68, 0xC7, 0x7E, 0x2F, 0xB4, 0x4E
   308                              <1> sevEsResetBlockEnd:
   309                              <1> 
   310                              <1> ;
   311                              <1> ; Table footer:
   312                              <1> ;
   313                              <1> ; length of whole table (16 bit word)
   314                              <1> ; GUID (table footer): 96b582de-1fb2-45f7-baea-a366c55a082d
   315                              <1> ;
   316 00000ADE 8800                <1>     DW      guidedStructureEnd - guidedStructureStart
   317 00000AE0 DE82B596B21FF745    <1>     DB      0xDE, 0x82, 0xB5, 0x96, 0xB2, 0x1F, 0xF7, 0x45
   318 00000AE8 BAEAA366C55A082D    <1>     DB      0xBA, 0xEA, 0xA3, 0x66, 0xC5, 0x5A, 0x08, 0x2D
   319                              <1> 
   320                              <1> guidedStructureEnd:
   321                              <1> 
   322                              <1> ALIGN   16
   323                              <1> 
   324                              <1> ;
   325                              <1> ; 0xffffffe0
   326                              <1> ;
   327 00000AF0 000000000000000000- <1>     DD      0, 0, 0
   327 00000AF9 000000              <1>
   328                              <1> 
   329                              <1> ;
   330                              <1> ; The VTF signature (0xffffffec)
   331                              <1> ;
   332                              <1> ; VTF-0 means that the VTF (Volume Top File) code does not require
   333                              <1> ; any fixups.
   334                              <1> ;
   335                              <1> vtfSignature:
   336 00000AFC 56544600            <1>     DB      'V', 'T', 'F', 0
   337                              <1> 
   338                              <1> ALIGN   16
   339                              <1> 
   340                              <1> resetVector:
   341                              <1> ;
   342                              <1> ; Reset Vector
   343                              <1> ;
   344                              <1> ; This is where the processor will begin execution
   345                              <1> ;
   346                              <1> ; In IA32 we follow the standard reset vector flow. While in X64, Td guest
   347                              <1> ; may be supported. Td guest requires the startup mode to be 32-bit
   348                              <1> ; protected mode but the legacy VM startup mode is 16-bit real mode.
   349                              <1> ; To make NASM generate such shared entry code that behaves correctly in
   350                              <1> ; both 16-bit and 32-bit mode, more BITS directives are added.
   351                              <1> ;
   352                              <1> %ifdef ARCH_IA32
   353                              <1>     nop
   354                              <1>     nop
   355                              <1>     jmp     EarlyBspInitReal16
   356                              <1> 
   357                              <1> %else
   358                              <1> 
   359 00000B00 0F20C0              <1>     mov     eax, cr0
   360 00000B03 A801                <1>     test    al, 1
   361 00000B05 7405                <1>     jz      .Real
   362                              <1> BITS 32
   363 00000B07 E92CFFFFFF          <1>     jmp     Main32
   364                              <1> BITS 16
   365                              <1> .Real:
   366 00000B0C E911FF              <1>     jmp     EarlyBspInitReal16
   367                              <1> 
   368                              <1> %endif
   369                              <1> 
   370 00000B0F 90                  <1> ALIGN   16
   371                              <1> 
   372                              <1> fourGigabytes:
   373                              <1> 
